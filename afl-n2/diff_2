45a46
> #include <dlfcn.h>
47d47
< #include <sys/fcntl.h>
58,59d57
< #include <sys/socket.h>
< 
68,80d65
< static char* stat_vector[20];
< 
< #define FUZ_SRC 0
< #define S2E_SRC 1
< #define TRA_SRC 2
< 
< int imported_paths[3] = {0, 0, 0};
< int checked_paths[3] = {0, 0, 0};
< 
< int sync_times = 0;
< int sync_count = 0;
< 
< 
84,85d68
<           // *local_out_dir,
<           *remote_out_dir,
94d76
< 
108a91
>            term_too_small,            /* terminal dimensions too small    */
122,127c105,107
<            dev_urandom_fd,            /* Persistent fd for /dev/urandom   */
<            dev_null_fd;               /* Persistent fd for /dev/null      */
< 
< static s32 qemu_log_fd;                    /*Persistent fd for /tmp/afl_log*/
< 
< static s32 fsrv_ctl_fd,               /* Fork server control pipe (write) */
---
>            dev_urandom_fd = -1,       /* Persistent fd for /dev/urandom   */
>            dev_null_fd = -1,          /* Persistent fd for /dev/null      */
>            fsrv_ctl_fd,               /* Fork server control pipe (write) */
130d109
< 
132,134c111,112
<            child_pid = -1;            /* PID of the fuzzed program        */
< 
< static int is_qemu_log = 0;
---
>            child_pid = -1,            /* PID of the fuzzed program        */
>            out_dir_fd = -1;           /* FD of the lock file              */
171,172c149
<            first_crash_time = 0,      /* Add for cgc                      */
<            last_crash_time = 0,       /* Time for most recent crash (ms)  */
---
>            last_crash_time,           /* Time for most recent crash (ms)  */
201c178
< static u32 rand_cnt = RESEED_RNG;     /* Random number counter            */
---
> static u32 rand_cnt;                  /* Random number counter            */
239,240c216,217
<   struct queue_entry *next;             /* Next element, if any             */
<                    // *next_100         /* 100 elements ahead               */
---
>   struct queue_entry *next//,           /* Next element, if any             */
>                    /* *next_100*/;       /* 100 elements ahead               */
251d227
< // static struct queue_entry** top_rated;
264a241,242
> static u8* (*post_handler)(u8* buf, u32* len);
> 
772d749
<   // fname = alloc_printf("%s/fuzz_bitmap", local_out_dir);
777a755
> 
892a871
> 
979a959
> 
1147d1126
< 
1320,1332c1299,1325
<     ACTF("shm_id: %i", (int)shm_id);
< #ifdef __x86_64__
<     ACTF("trace_bits@ 0x%016lx", (unsigned long)trace_bits);
<     ACTF("virgin_bits@ 0x%016lx", (unsigned long)virgin_bits);
<     ACTF("virgin_hang@ 0x%016lx", (unsigned long)virgin_hang);
<     ACTF("virgin_crash@ 0x%016lx", (unsigned long)virgin_crash);
< #else
<     ACTF("trace_bits@ 0x%08x", (unsigned int)trace_bits);
<     ACTF("virgin_bits@ 0x%08x", (unsigned int)virgin_bits);
<     ACTF("virgin_hang@ 0x%08x", (unsigned int)virgin_hang);
<     ACTF("virgin_crash@ 0x%08x", (unsigned int)virgin_crash);
< #endif /* ^__x86_64__ */
<   
---
> }
> 
> 
> /* Load postprocessor, if available. */
> 
> static void setup_post(void) {
> 
>   void* dh;
>   u8* fn = getenv("AFL_POST_LIBRARY");
>   u32 tlen = 6;
> 
>   if (!fn) return;
> 
>   ACTF("Loading postprocessor from '%s'...", fn);
> 
>   dh = dlopen(fn, RTLD_NOW);
>   if (!dh) FATAL("%s", dlerror());
> 
>   post_handler = dlsym(dh, "afl_postprocess");
>   if (!post_handler) FATAL("Symbol 'afl_postprocess' not found.");
> 
>   /* Do a quick test. It's better to segfault now than later =) */
> 
>   post_handler("hello", &tlen);
> 
>   OKF("Postprocessor installed successfully.");
> 
1449a1443,1579
> /* Read extras from a file, sort by size. */
> 
> static void load_extras_file(u8* fname, u32* min_len, u32* max_len,
>                              u32 dict_level) {
> 
>   FILE* f;
>   u8  buf[MAX_LINE];
>   u8  *lptr;
>   u32 cur_line = 0;
> 
>   f = fopen(fname, "r");
> 
>   if (!f) PFATAL("Unable to open '%s'", fname);
> 
>   while ((lptr = fgets(buf, MAX_LINE, f))) {
> 
>     u8 *rptr, *wptr;
>     u32 klen = 0;
> 
>     cur_line++;
> 
>     /* Trim on left and right. */
> 
>     while (isspace(*lptr)) lptr++;
> 
>     rptr = lptr + strlen(lptr) - 1;
>     while (rptr >= lptr && isspace(*rptr)) rptr--;
>     rptr++;
>     *rptr = 0;
> 
>     /* Skip empty lines and comments. */
> 
>     if (!*lptr || *lptr == '#') continue;
> 
>     /* All other lines must end with '"', which we can consume. */
> 
>     rptr--;
> 
>     if (rptr < lptr || *rptr != '"')
>       FATAL("Malformed name=\"value\" pair in line %u.", cur_line);
> 
>     *rptr = 0;
> 
>     /* Skip alphanumerics and dashes (label). */
> 
>     while (isalnum(*lptr) || *lptr == '_') lptr++;
> 
>     /* If @number follows, parse that. */
> 
>     if (*lptr == '@') {
> 
>       lptr++;
>       if (atoi(lptr) > dict_level) continue;
>       while (isdigit(*lptr)) lptr++;
> 
>     }
> 
>     /* Skip whitespace and = signs. */
> 
>     while (isspace(*lptr) || *lptr == '=') lptr++;
> 
>     /* Consume opening '"'. */
> 
>     if (*lptr != '"')
>       FATAL("Malformed name=\"keyword\" pair in line %u.", cur_line);
> 
>     lptr++;
> 
>     if (!*lptr) FATAL("Empty keyword in line %u.", cur_line);
> 
>     /* Okay, let's allocate memory and copy data between "...", handling
>        \xNN escaping, \\, and \". */
> 
>     extras = ck_realloc_block(extras, (extras_cnt + 1) *
>                sizeof(struct extra_data));
> 
>     wptr = extras[extras_cnt].data = ck_alloc(rptr - lptr);
> 
>     while (*lptr) {
> 
>       char* hexdigits = "0123456789abcdef";
> 
>       switch (*lptr) {
> 
>         case 1 ... 31:
>         case 128 ... 255:
>           FATAL("Non-printable characters in line %u.", cur_line);
> 
>         case '\\':
> 
>           lptr++;
> 
>           if (*lptr == '\\' || *lptr == '"') {
>             *(wptr++) = *(lptr++);
>             klen++;
>             break;
>           }
> 
>           if (*lptr != 'x' || !isxdigit(lptr[1]) || !isxdigit(lptr[2]))
>             FATAL("Invalid escaping (not \\xNN) in line %u.", cur_line);
> 
>           *(wptr++) =
>             ((strchr(hexdigits, tolower(lptr[1])) - hexdigits) << 4) |
>             (strchr(hexdigits, tolower(lptr[2])) - hexdigits);
> 
>           lptr += 3;
>           klen++;
> 
>           break;
> 
>         default:
> 
>           *(wptr++) = *(lptr++);
>           klen++;
> 
>       }
> 
>     }
> 
>     extras[extras_cnt].len = klen;
> 
>     if (extras[extras_cnt].len > MAX_DICT_FILE)
>       FATAL("Keyword too big in line %u (%s, limit is %s)", cur_line,
>             DMS(klen), DMS(MAX_DICT_FILE));
> 
>     if (*min_len > klen) *min_len = klen;
>     if (*max_len < klen) *max_len = klen;
> 
>     extras_cnt++;
> 
>   }
> 
>   fclose(f);
> 
> }
> 
> 
1456c1586,1587
<   u32 min_len = MAX_DICT_FILE, max_len = 0;
---
>   u32 min_len = MAX_DICT_FILE, max_len = 0, dict_level = 0;
>   u8* x;
1458c1589,1598
<   ACTF("Loading extra dictionary from '%s'...", dir);
---
>   /* If the name ends with @, extract level and continue. */
> 
>   if ((x = strchr(dir, '@'))) {
> 
>     *x = 0;
>     dict_level = atoi(x + 1);
> 
>   }
> 
>   ACTF("Loading extra dictionary from '%s' (level %u)...", dir, dict_level);
1462c1602,1613
<   if (!d) PFATAL("Unable to open '%s'", dir);
---
>   if (!d) {
> 
>     if (errno == ENOTDIR) {
>       load_extras_file(dir, &min_len, &max_len, dict_level);
>       goto check_and_sort;
>     }
> 
>     PFATAL("Unable to open '%s'", dir);
> 
>   }
> 
>   if (x) FATAL("Dictinary levels not supported for directories.");
1507a1659,1661
> 
> check_and_sort:
> 
1525a1680,1681
> 
> 
1653c1809
<     u8* fn = alloc_printf("%s/queue/.state/auto_extras/auto_%08u", out_dir, i);
---
>     u8* fn = alloc_printf("%s/queue/.state/auto_extras/auto_%06u", out_dir, i);
1679c1835
<     u8* fn = alloc_printf("%s/.state/auto_extras/auto_%08u", in_dir, i);
---
>     u8* fn = alloc_printf("%s/.state/auto_extras/auto_%06u", in_dir, i);
1731,1741d1886
< /*CGC now set up fds for communication between multiple CBs*/
< // static void init_cbs_comm_fds()
< // {
< //   cbs_comm_fds = ck_alloc(sizeof(int) * num_of_cbs * 2);
< //   int i;
< //   for(i=0; i<num_of_cbs; i++)
< //   {
< //     if(0 != socketpair(AF_UNIX, SOCK_STREAM, 0, cbs_comm_fds + 2 * i))
< //       PFATAL("Cannot create socket");
< //   }
< // }
1758c1903
<   ACTF("Spinning up the fork server ");
---
>   ACTF("Spinning up the fork server...");
1771c1916
<       soft 128. Let's try to fix that... */
---
>        soft 128. Let's try to fix that... */
1814,1818c1959
<     
<     if(!is_qemu_log)
<       dup2(dev_null_fd, 2);
<     else
<       dup2(qemu_log_fd, 2);
---
>     dup2(dev_null_fd, 2);
1833c1974
<     if (dup2(ctl_pipe[0], FORKSRV_FD ) < 0) PFATAL("dup2() failed");
---
>     if (dup2(ctl_pipe[0], FORKSRV_FD) < 0) PFATAL("dup2() failed");
1840a1982
>     close(out_dir_fd);
1843a1986
> 
1847c1990
<     setenv("LD_BIND_NOW", "1", 0);
---
>     if (!getenv("LD_BIND_LAZY")) setenv("LD_BIND_NOW", "1", 0);
1877,1890c2020
<   fsrv_st_fd = st_pipe[0];
< 
< 
<   // if(write(fsrv_ctl_fd[i], &i, 4) != 4)
<   // {
<   //   if (stop_soon) return ;
<   //   FATAL("Unable to send cb_id to the new fork server of CB %02i (OOM?)", i);
<   // }
< 
<   // if(write(fsrv_ctl_fd[i], shm_id + i, 4) != 4)
<   // {
<   //   if (stop_soon) return ;
<   //   FATAL("Unable to send shm_id to the new fork server of CB %02i (OOM?)", i);
<   // }
---
>   fsrv_st_fd  = st_pipe[0];
1912d2041
<     // continue;
1918c2047
<   if (waitpid(forksrv_pid, &status, WUNTRACED) <= 0)
---
>   if (waitpid(forksrv_pid, &status, 0) <= 0)
1963c2092
<           "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>            "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
1965c2094
<           "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>            "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
1968c2097
<            "      Tip: you can use ppvm (http://jwilk.net/software/ppvm) to quickly\n"
---
>            "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
2014c2143
<          "    handshake with the injected code. There are two probable explanations:\n\n"
---
>          "    handshake with the injected code. There are %s probable explanations:\n\n"
2015a2145
>          "%s"
2021c2151
<         "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>          "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
2023c2153
<         "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>          "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
2026,2027c2156,2157
<         "      Tip: you can use ppvm (http://jwilk.net/software/ppvm) to quickly\n"
<         "      estimate the required amount of virtual memory for the binary.\n\n"
---
>          "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
>          "      estimate the required amount of virtual memory for the binary.\n\n"
2029,2031c2159,2165
<         "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
<         "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
<         DMS(mem_limit << 20), mem_limit - 1);
---
>          "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
>          "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
>          getenv(DEFER_ENV_VAR) ? "three" : "two",
>          getenv(DEFER_ENV_VAR) ?
>          "    - You are using deferred forkserver, but __AFL_INIT() is never\n"
>          "      reached before the program terminates.\n\n" : "",
>          DMS(mem_limit << 20), mem_limit - 1);
2045a2180,2181
>   static u32 prev_timed_out = 0;
> 
2049d2184
<   
2066c2201
<     child_pid= fork();
---
>     child_pid = fork();
2112a2248,2249
>       /* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */
> 
2113a2251,2253
>       close(out_dir_fd);
>       close(dev_urandom_fd);
>       close(fileno(plot_file));
2141c2281
<     if ((res = write(fsrv_ctl_fd, &status, 4)) != 4) {
---
>     if ((res = write(fsrv_ctl_fd, &prev_timed_out, 4)) != 4) {
2158d2297
<   
2171c2310
<     if (waitpid(child_pid, &status, WUNTRACED) <= 0) PFATAL("waitpid() failed");
---
>     if (waitpid(child_pid, &status, 0) <= 0) PFATAL("waitpid() failed");
2185c2324
<  
---
> 
2193d2331
<   
2195,2197c2333,2335
<     /* Any subsequent operations on trace_bits must not be moved by the
<        compiler above this point. Past this location, trace_bits[] behave
<        very normally and do not have to be treated as volatile. */
---
>   /* Any subsequent operations on trace_bits must not be moved by the
>      compiler below this point. Past this location, trace_bits[] behave
>      very normally and do not have to be treated as volatile. */
2208c2346,2348
<   
---
> 
>   prev_timed_out = child_timed_out;
> 
2218,2219c2358,2359
< /* A somewhat nasty hack for MSAN, which doesn't support abort_on_error and
<    must use a special exit code. */
---
>   /* A somewhat nasty hack for MSAN, which doesn't support abort_on_error and
>      must use a special exit code. */
2326c2466
<   if (!dumb_mode && !no_forkserver && !forksrv_pid)
---
>   if (dumb_mode != 1 && !no_forkserver && !forksrv_pid)
2328c2468
<   // while(1);
---
> 
2338c2478
<     // ACTF("run_target() 1 at staget_cur: %d", stage_cur);
---
> 
2340c2480
<     
---
> 
2352c2492
<     // ACTF("cksum: %u @%d", cksum, stage_cur);
---
> 
2368c2508
<   
---
> 
2383a2524
> 
2389c2530
<   
---
> 
2409a2551
> 
2426d2567
<   {
2428d2568
<   }
2441d2580
<   u32 id = 0;
2442a2582
>   u8* skip_crashes = getenv("AFL_SKIP_CRASHES");
2491c2631
<           if (timeout_given == 2) {
---
>           if (timeout_given > 1) {
2525a2666,2672
>         if (skip_crashes) {
>           WARNF("Test case results in a crash (skipping)");
>           q->cal_failed = CAL_CHANCES;
>           cal_failures++;
>           break;
>         }
> 
2547c2694
<                "      Tip: you can use ppvm (http://jwilk.net/software/ppvm) to quickly\n"
---
>                "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
2610d2756
<     id++;
2617,2618c2763,2764
<       FATAL("All test cases time out, giving up!");
<       // WARNF("All test cases timeout!");
---
>       FATAL("All test cases time out%s, giving up!",
>             skip_crashes ? " or crash" : "");
2620,2621c2766,2768
<     WARNF("Skipped %u test cases (%0.02f%%) due to timeouts.", cal_failures,
<           ((double)cal_failures) * 100 / queued_paths);
---
>     WARNF("Skipped %u test cases (%0.02f%%) due to timeouts%s.", cal_failures,
>           ((double)cal_failures) * 100 / queued_paths,
>           skip_crashes ? " or crashes" : "");
2693c2840
<         sscanf(rsl + 3, "%08u", &orig_id) == 1 && orig_id == id) {
---
>         sscanf(rsl + 3, "%06u", &orig_id) == 1 && orig_id == id) {
2706c2853
<       if (src_str && sscanf(src_str + 1, "%08u", &src_id) == 1) {
---
>       if (src_str && sscanf(src_str + 1, "%06u", &src_id) == 1) {
2726c2873
<       nfn = alloc_printf("%s/queue/id:%08u,orig:%s", out_dir, id, use_name);
---
>       nfn = alloc_printf("%s/queue/id:%06u,orig:%s", out_dir, id, use_name);
2730c2877
<       nfn = alloc_printf("%s/queue/id_%08u", out_dir, id);
---
>       nfn = alloc_printf("%s/queue/id_%06u", out_dir, id);
2767c2914
<     sprintf(ret, "sync:%s,src:%08u", syncing_party, syncing_case);
---
>     sprintf(ret, "sync:%s,src:%06u", syncing_party, syncing_case);
2771c2918
<     sprintf(ret, "src:%08u", current_entry);
---
>     sprintf(ret, "src:%06u", current_entry);
2774c2921
<       sprintf(ret + strlen(ret), "+%08u", splicing_with);
---
>       sprintf(ret + strlen(ret), "+%06u", splicing_with);
2877c3024
<     fn = alloc_printf("%s/queue/id:%08u,%s", out_dir, queued_paths,
---
>     fn = alloc_printf("%s/queue/id:%06u,%s", out_dir, queued_paths,
2882c3029
<     fn = alloc_printf("%s/queue/id_%08u", out_dir, queued_paths);
---
>     fn = alloc_printf("%s/queue/id_%06u", out_dir, queued_paths);
2900d3046
< 
2945c3091
<       fn = alloc_printf("%s/hangs/id:%08llu,%s", out_dir,
---
>       fn = alloc_printf("%s/hangs/id:%06llu,%s", out_dir,
2950c3096
<       fn = alloc_printf("%s/hangs/id_%08llu", out_dir,
---
>       fn = alloc_printf("%s/hangs/id_%06llu", out_dir,
2986c3132
<       fn = alloc_printf("%s/crashes/id:%08llu,sig:%02u,%s", out_dir,
---
>       fn = alloc_printf("%s/crashes/id:%06llu,sig:%02u,%s", out_dir,
2991c3137
<       fn = alloc_printf("%s/crashes/id_%08llu_%02u", out_dir, unique_crashes,
---
>       fn = alloc_printf("%s/crashes/id_%06llu_%02u", out_dir, unique_crashes,
2996,3000d3141
<       if(unique_crashes == 0)
<       {
<         first_crash_time = get_cur_time();
<       }
< 
3039,3042d3179
<   // char cmd[128];
<   // sprintf(cmd, "ln -sf %s/fuzzer_stats /home/vagrant/fuzzer_stats", out_dir);
<   // system(cmd);
< 
3045,3047c3182,3183
<   // if (in_place_resume) fn = alloc_printf("%s/fuzzer_stats", out_dir);
<   // else fn = alloc_printf("%s/../fuzzer_stats", in_dir);
<   fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
---
>   if (in_place_resume) fn = alloc_printf("%s/fuzzer_stats", out_dir);
>   else fn = alloc_printf("%s/../fuzzer_stats", in_dir);
3066a3203,3239
> /* The same, but for timeouts. The idea is that when resuming sessions without
>    -t given, we don't want to keep auto-scaling the timeout over and over
>    again to prevent it from growing due to random flukes. */
> 
> static void find_timeout(void) {
> 
>   static u8 tmp[4096]; /* Ought to be enough for anybody. */
> 
>   u8  *fn, *off;
>   s32 fd, i;
>   u32 ret;
> 
>   if (!resuming_fuzz) return;
> 
>   if (in_place_resume) fn = alloc_printf("%s/fuzzer_stats", out_dir);
>   else fn = alloc_printf("%s/../fuzzer_stats", in_dir);
> 
>   fd = open(fn, O_RDONLY);
>   ck_free(fn);
> 
>   if (fd < 0) return;
> 
>   i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */
>   close(fd);
> 
>   off = strstr(tmp, "exec_timeout   : ");
>   if (!off) return;
> 
>   ret = atoi(off + 17);
>   if (ret <= 4) return;
> 
>   exec_tmout = ret;
>   timeout_given = 3;
> 
> }
> 
> 
3073,3074c3246
<   // u8* fn = alloc_printf("%s/fuzzer_stats", out_dir);
<   u8* fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
---
>   u8* fn = alloc_printf("%s/fuzzer_stats", out_dir);
3099,3129c3271,3295
<   fprintf(f, "start_time                  : %llu\n"
<              "last_update                 : %llu\n"
<              "fuzzer_pid                  : %u\n"
<              "first_crash_time            : %llu\n"
<              "last_crash_time             : %llu\n"
<              "cycles_done                 : %llu\n"
<              "execs_done                  : %llu\n"
<              "execs_per_sec               : %0.02f\n"
<              "paths_total                 : %u\n"
<              "paths_found                 : %u\n"
<              "paths_imported              : %u\n"
<              "max_depth                   : %u\n"
<              "cur_path                    : %u\n"
<              "pending_favs                : %u\n"
<              "pending_total               : %u\n"
<              "variable_paths              : %u\n"
<              "bitmap_cvg                  : %0.02f%%\n"
<              "unique_crashes              : %llu\n"
<              "unique_hangs                : %llu\n"
<              "imported_paths              : %u\n"
<              "checked_paths               : %i\n"
<              "imported_paths_fuz          : %i\n"
<              "checked_paths_fuz           : %i\n"
<              "imported_paths_s2e          : %i\n"
<              "checked_paths_s2e           : %i\n"
<              "imported_paths_traffic      : %i\n"
<              "checked_paths_traffic       : %i\n" 
<              "sync_times                  : %i\n"
<              "afl_banner                  : %s\n"
<              "afl_version                 : " VERSION "\n"
<              "command_line                : %s\n",
---
>   fprintf(f, "start_time     : %llu\n"
>              "last_update    : %llu\n"
>              "fuzzer_pid     : %u\n"
>              "cycles_done    : %llu\n"
>              "execs_done     : %llu\n"
>              "execs_per_sec  : %0.02f\n"
>              "paths_total    : %u\n"
>              "paths_favored  : %u\n"
>              "paths_found    : %u\n"
>              "paths_imported : %u\n"
>              "max_depth      : %u\n"
>              "cur_path       : %u\n"
>              "pending_favs   : %u\n"
>              "pending_total  : %u\n"
>              "variable_paths : %u\n"
>              "bitmap_cvg     : %0.02f%%\n"
>              "unique_crashes : %llu\n"
>              "unique_hangs   : %llu\n"
>              "last_path      : %llu\n"
>              "last_crash     : %llu\n"
>              "last_hang      : %llu\n"
>              "exec_timeout   : %u\n"
>              "afl_banner     : %s\n"
>              "afl_version    : " VERSION "\n"
>              "command_line   : %s\n",
3131d3296
<              first_crash_time / 1000, last_crash_time /1000,
3133,3134c3298,3299
<              queued_paths, queued_discovered, queued_imported, max_depth,
<              current_entry, pending_favored, pending_not_fuzzed,
---
>              queued_paths, queued_favored, queued_discovered, queued_imported,
>              max_depth, current_entry, pending_favored, pending_not_fuzzed,
3136,3141c3301,3303
<              queued_imported, sync_count, 
<              imported_paths[FUZ_SRC], checked_paths[FUZ_SRC],
<              imported_paths[S2E_SRC], checked_paths[S2E_SRC],
<              imported_paths[TRA_SRC], checked_paths[TRA_SRC],
<              sync_times,
<              use_banner, orig_cmdline); /* ignore errors */
---
>              last_path_time / 1000, last_crash_time / 1000,
>              last_hang_time / 1000, exec_tmout, use_banner, orig_cmdline);
>              /* ignore errors */
3317,3319c3479
<   // u8 *fn = alloc_printf("%s/fuzzer_stats", out_dir);
<   u8* fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
<   static s32 out_dir_fd;
---
>   u8 *fn = alloc_printf("%s/fuzzer_stats", out_dir);
3327a3488,3489
> #ifndef __sun
> 
3339a3502,3503
> #endif /* !__sun */
> 
3404d3567
<   // fn = alloc_printf("%s/.synced", local_out_dir);
3439,3441c3602,3608
<   fn = alloc_printf("%s/crashes/README.txt", out_dir);
<   unlink(fn); /* Ignore errors */
<   ck_free(fn);
---
>   if (!in_place_resume) {
> 
>     fn = alloc_printf("%s/crashes/README.txt", out_dir);
>     unlink(fn); /* Ignore errors */
>     ck_free(fn);
> 
>   }
3452a3620,3621
> #ifndef SIMPLE_FILES
> 
3456a3626,3633
> #else
> 
>     u8* nfn = alloc_printf("%s_%04u%02u%02u%02u%02u%02u", fn,
>                            t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
>                            t->tm_hour, t->tm_min, t->tm_sec);
> 
> #endif /* ^!SIMPLE_FILES */
> 
3473a3651,3652
> #ifndef SIMPLE_FILES
> 
3477a3657,3664
> #else
> 
>     u8* nfn = alloc_printf("%s_%04u%02u%02u%02u%02u%02u", fn,
>                            t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
>                            t->tm_hour, t->tm_min, t->tm_sec);
> 
> #endif /* ^!SIMPLE_FILES */
> 
3489d3675
<   // fn = alloc_printf("%s/.cur_input", local_out_dir);
3494d3679
<   // fn = alloc_printf("%s/fuzz_bitmap", local_out_dir);
3499,3500c3684
<     // fn  = alloc_printf("%s/fuzzer_stats", out_dir);
<     fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
---
>     fn  = alloc_printf("%s/fuzzer_stats", out_dir);
3506d3689
<   // fn = alloc_printf("%s/plot_data", local_out_dir);
3531a3715,3717
> static void check_term_size(void);
> 
> 
3611a3798,3802
>   /* Honor AFL_EXIT_WHEN_DONE. */
> 
>   if (!dumb_mode && cycles_wo_finds > 20 && !pending_not_fuzzed &&
>       getenv("AFL_EXIT_WHEN_DONE")) stop_soon = 1;
> 
3626a3818,3819
>     check_term_size();
> 
3630a3824,3832
>   if (term_too_small) {
> 
>     SAYF(cBRI "Your terminal is too small to display the UI.\n"
>          "Please resize terminal window to at least 80x25.\n" cNOR);
> 
>     return;
> 
>   }
> 
3730c3932
<   /* This gets funny becuse we want to print several variable-length variables
---
>   /* This gets funny because we want to print several variable-length variables
3837c4039
<             DI(stage_finds[STAGE_FLIP4]), DI(stage_cycles[STAGE_FLIP2]),
---
>             DI(stage_finds[STAGE_FLIP2]), DI(stage_cycles[STAGE_FLIP2]),
3878,3887d4079
<   u8 _tmp[256];
<   memset(_tmp, ' ', banner_pad);
<   if(sync_id)
<     sprintf(_tmp, "%s|%s[%s]", DI(queued_imported), DI(sync_count), DI(sync_times));
<   else
<     sprintf(_tmp, "%s", (u8*)"n/a");
< 
<   // SAYF(bV bSTOP "  dictionary : " cNOR "%-37s " bSTG bV bSTOP
<   //      "  imported : " cNOR "%-10s " bSTG bV "\n", tmp,
<   //      sync_id ? DI(queued_imported) : (u8*)"n/a");
3889,3890c4081,4083
<        "  imported : " cNOR "%-10s " bSTG bV "\n", tmp, _tmp);
<   
---
>        "  imported : " cNOR "%-10s " bSTG bV "\n", tmp,
>        sync_id ? DI(queued_imported) : (u8*)"n/a");
> 
4053a4247,4250
>   } else if (timeout_given == 3) {
> 
>     ACTF("Applying timeout settings from resumed session (%u ms).", exec_tmout);
> 
4119c4316
<       // ACTF("run_target() 2");
---
> 
4182c4379
<     
---
> 
4205a4403,4409
>   if (post_handler) {
> 
>     out_buf = post_handler(out_buf, &len);
>     if (!out_buf || !len) return 0;
> 
>   }
> 
4207c4411
<   // ACTF("run_target() 3");
---
> 
4301c4505
<      coverage translates to better targets. Multipler from 0.25x to 3x. */
---
>      coverage translates to better targets. Multiplier from 0.25x to 3x. */
4348a4553,4738
> /* Helper function to see if a particular change (xor_val = old ^ new) could
>    be a product of deterministic bit flips with the lengths and stepovers
>    attempted by afl-fuzz. This is used to avoid dupes in some of the
>    deterministic fuzzing operations that follow bit flips. We also
>    return 1 if xor_val is zero, which implies that the old and attempted new
>    values are identical and the exec would be a waste of time. */
> 
> static u8 could_be_bitflip(u32 xor_val) {
> 
>   u32 sh = 0;
> 
>   if (!xor_val) return 1;
> 
>   /* Shift left until first bit set. */
> 
>   while (!(xor_val & 1)) { sh++; xor_val >>= 1; }
> 
>   /* 1-, 2-, and 4-bit patterns are OK anywhere. */
> 
>   if (xor_val == 1 || xor_val == 3 || xor_val == 15) return 1;
> 
>   /* 8-, 16-, and 32-bit patterns are OK only if shift factor is
>      divisible by 8, since that's the stepover for these ops. */
> 
>   if (sh & 7) return 0;
> 
>   if (xor_val == 0xff || xor_val == 0xffff || xor_val == 0xffffffff)
>     return 1;
> 
>   return 0;
> 
> }
> 
> 
> /* Helper function to see if a particular value is reachable through
>    arithmetic operations. Used for similar purposes. */
> 
> static u8 could_be_arith(u32 old_val, u32 new_val, u8 blen) {
> 
>   u32 i, ov = 0, nv = 0, diffs = 0;
> 
>   if (old_val == new_val) return 1;
> 
>   /* See if one-byte adjustments to any byte could produce this result. */
> 
>   for (i = 0; i < blen; i++) {
> 
>     u8 a = old_val >> (8 * i),
>        b = new_val >> (8 * i);
> 
>     if (a != b) { diffs++; ov = a; nv = b; }
> 
>   }
> 
>   /* If only one byte differs and the values are within range, return 1. */
> 
>   if (diffs == 1) {
> 
>     if ((u8)(ov - nv) <= ARITH_MAX ||
>         (u8)(nv - ov) <= ARITH_MAX) return 1;
> 
>   }
> 
>   if (blen == 1) return 0;
> 
>   /* See if two-byte adjustments to any byte would produce this result. */
> 
>   diffs = 0;
> 
>   for (i = 0; i < blen / 2; i++) {
> 
>     u16 a = old_val >> (16 * i),
>         b = new_val >> (16 * i);
> 
>     if (a != b) { diffs++; ov = a; nv = b; }
> 
>   }
> 
>   /* If only one word differs and the values are within range, return 1. */
> 
>   if (diffs == 1) {
> 
>     if ((u16)(ov - nv) <= ARITH_MAX ||
>         (u16)(nv - ov) <= ARITH_MAX) return 1;
> 
>     ov = SWAP16(ov); nv = SWAP16(nv);
> 
>     if ((u16)(ov - nv) <= ARITH_MAX ||
>         (u16)(nv - ov) <= ARITH_MAX) return 1;
> 
>   }
> 
>   /* Finally, let's do the same thing for dwords. */
> 
>   if (blen == 4) {
> 
>     if ((u32)(old_val - new_val) <= ARITH_MAX ||
>         (u32)(new_val - old_val) <= ARITH_MAX) return 1;
> 
>     new_val = SWAP32(new_val);
>     old_val = SWAP32(old_val);
> 
>     if ((u32)(old_val - new_val) <= ARITH_MAX ||
>         (u32)(new_val - old_val) <= ARITH_MAX) return 1;
> 
>   }
> 
>   return 0;
> 
> }
> 
> 
> /* Last but not least, a similar helper to see if insertion of an 
>    interesting integer is redundant given the insertions done for
>    shorter blen. The last param (check_le) is set if the caller
>    already executed LE insertion for current blen and wants to see
>    if BE variant passed in new_val is unique. */
> 
> static u8 could_be_interest(u32 old_val, u32 new_val, u8 blen, u8 check_le) {
> 
>   u32 i, j;
> 
>   if (old_val == new_val) return 1;
> 
>   /* See if one-byte insertions from interesting_8 over old_val could
>      produce new_val. */
> 
>   for (i = 0; i < blen; i++) {
> 
>     for (j = 0; j < sizeof(interesting_8); j++) {
> 
>       u32 tval = (old_val & ~(0xff << (i * 8))) |
>                  (((u8)interesting_8[j]) << (i * 8));
> 
>       if (new_val == tval) return 1;
> 
>     }
> 
>   }
> 
>   /* Bail out unless we're also asked to examine two-byte LE insertions
>      as a preparation for BE attempts. */
> 
>   if (blen == 2 && !check_le) return 0;
> 
>   /* See if two-byte insertions over old_val could give us new_val. */
> 
>   for (i = 0; i < blen - 1; i++) {
> 
>     for (j = 0; j < sizeof(interesting_16) / 2; j++) {
> 
>       u32 tval = (old_val & ~(0xffff << (i * 8))) |
>                  (((u16)interesting_16[j]) << (i * 8));
> 
>       if (new_val == tval) return 1;
> 
>       /* Continue here only if blen > 2. */
> 
>       if (blen > 2) {
> 
>         tval = (old_val & ~(0xffff << (i * 8))) |
>                (SWAP16(interesting_16[j]) << (i * 8));
> 
>         if (new_val == tval) return 1;
> 
>       }
> 
>     }
> 
>   }
> 
>   if (blen == 4 && check_le) {
> 
>     /* See if four-byte insertions could produce the same result
>        (LE only). */
> 
>     for (j = 0; j < sizeof(interesting_32) / 4; j++)
>       if (new_val == (u32)interesting_32[j]) return 1;
> 
>   }
> 
>   return 0;
> 
> }
> 
> 
4350c4740
<    function is a tad too long... returns 0 if fuzzed successfuly, 1 if
---
>    function is a tad too long... returns 0 if fuzzed successfully, 1 if
4547c4937
<     if ((stage_cur & 7) == 7) {
---
>     if (!dumb_mode && (stage_cur & 7) == 7) {
4761c5151
<     if (!*(u16*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
4797c5187,5188
<     if (!*(u32*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
>         !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
4852,4867c5243,5246
<       /* Don't bother with arithmetics that produce results equivalent
<          to previously-attempted bitflips. To evaluate this, we look at
<          XOR of the values before and after the arithmetic operation, and
<          compare them to XOR results that can be produced by bitflips.
< 
<          Single bitflips can yield 1, 2, 4, 8, 16, 32, 64, 128,
<          Two-in-a-row can yield 1*, 3, 6, 12, 24, 48, 96, 128*, 192,
<          Four in a row: 1*, 3*, 7, 15, 30, 60, 120, 128*, 192*, 224, 240,
<          Full-byte flip (with a 1-byte stepover) takes care of 255.
< 
<        */
< 
<       if (r > 4 && r != 8  && r != 16 && r != 32 && r != 64 && r != 128 &&
<           r != 6 && r != 12 && r != 24 && r != 48 && r != 96 && r != 192 &&
<           r != 7 && r != 15 && r != 30 && r != 60 && r != 120 && r != 224 &&
<           r != 240 && r != 255) {
---
>       /* Do arithmetic operations only if the result couldn't be a product
>          of a bitflip. */
> 
>       if (!could_be_bitflip(r)) {
4877c5256
<       r = orig ^ (orig - j);
---
>       r =  orig ^ (orig - j);
4879,4881c5258
<       if (r > 4 && r != 8 && r != 16 && r != 32 && r != 64 && r != 128 &&
<           r != 6 && r != 12 && r != 24 && r != 48 && r != 96 && r != 192 &&
<           r != 15 && r != 30 && r != 60 && r != 120 && r != 240 && r != 255) {
---
>       if (!could_be_bitflip(r)) {
4919c5296
<     if (!*(u16*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
4927a5305,5309
>       u16 r1 = orig ^ (orig + j),
>           r2 = orig ^ (orig - j),
>           r3 = orig ^ SWAP16(SWAP16(orig) + j),
>           r4 = orig ^ SWAP16(SWAP16(orig) - j);
> 
4930,4934c5312,5313
<          & 0xff overflow checks).
< 
<          Since we're looking only at multi-byte operations, the
<          overlap with bitflips will be relatively modest and we don't
<          test for it here. */
---
>          & 0xff overflow checks) and if it couldn't be a product of
>          a bitflip. */
4938c5317
<       if ((orig & 0xff) + j > 0xff) {
---
>       if ((orig & 0xff) + j > 0xff && !could_be_bitflip(r1)) {
4948c5327
<       if ((orig & 0xff) < j) {
---
>       if ((orig & 0xff) < j && !could_be_bitflip(r2)) {
4962c5341,5342
<       if ((orig >> 8) + j > 0xff) {
---
> 
>       if ((orig >> 8) + j > 0xff && !could_be_bitflip(r3)) {
4972c5352
<       if ((orig >> 8) < j) {
---
>       if ((orig >> 8) < j && !could_be_bitflip(r4)) {
5009c5389,5390
<     if (!*(u32*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
>         !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
5017a5399,5403
>       u32 r1 = orig ^ (orig + j),
>           r2 = orig ^ (orig - j),
>           r3 = orig ^ SWAP32(SWAP32(orig) + j),
>           r4 = orig ^ SWAP32(SWAP32(orig) - j);
> 
5023c5409
<       if ((orig & 0xffff) + j > 0xffff) {
---
>       if ((orig & 0xffff) + j > 0xffff && !could_be_bitflip(r1)) {
5033c5419
<       if ((orig & 0xffff) < j) {
---
>       if ((orig & 0xffff) < j && !could_be_bitflip(r2)) {
5046,5047c5432,5433
<  
<       if ((SWAP32(orig) & 0xffff) + j > 0xffff) {
---
> 
>       if ((SWAP32(orig) & 0xffff) + j > 0xffff && !could_be_bitflip(r3)) {
5057c5443
<       if ((SWAP32(orig) & 0xffff) < j) {
---
>       if ((SWAP32(orig) & 0xffff) < j && !could_be_bitflip(r4)) {
5110,5112c5496
<       /* Skip if the new and original values are the same, or are within
<          +/- ARITH_MAX (in the latter case, we already tried this number
<          during the arith steps). */
---
>       /* Skip if the value could be a product of bitflips or arithmetics. */
5114,5115c5498,5499
<       if (((u8)(interesting_8[j] - orig)) <= ARITH_MAX ||
<           ((u8)(orig - interesting_8[j])) <= ARITH_MAX) {
---
>       if (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||
>           could_be_arith(orig, (u8)interesting_8[j], 1)) {
5154c5538
<     if (!*(u16*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
5163,5165d5546
<       u8 i_msb = ((u16)interesting_16[j]) >> 8,
<          o_msb = orig >> 8;
< 
5168,5171c5549,5550
<       /* Skip if values are the same or if both the orig value and
<          the current candidate have the same MSB value and are a
<          small integer - in which case, we covered this op while
<          working on interesting_8. */
---
>       /* Skip if this could be a product of a bitflip, arithmetics,
>          or single-byte interesting value insertion. */
5173,5174c5552,5554
<       if (interesting_16[j] != orig && 
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xff))) {
---
>       if (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &&
>           !could_be_arith(orig, (u16)interesting_16[j], 2) &&
>           !could_be_interest(orig, (u16)interesting_16[j], 2, 0)) {
5185,5189c5565,5568
<       o_msb = orig;
< 
<       if (SWAP16(interesting_16[j]) != interesting_16[j] && 
<           SWAP16(interesting_16[j]) != orig &&
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xff))) {
---
>       if ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &&
>           !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &&
>           !could_be_arith(orig, SWAP16(interesting_16[j]), 2) &&
>           !could_be_interest(orig, SWAP16(interesting_16[j]), 2, 1)) {
5227c5606,5607
<     if (!*(u32*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
>         !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
5236,5238d5615
<       u16 i_msb = ((u32)interesting_32[j]) >> 16,
<           o_msb = orig >> 16;
< 
5241,5242c5618,5623
<       if (interesting_32[j] != orig &&
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xffff))) {
---
>       /* Skip if this could be a product of a bitflip, arithmetics,
>          or word interesting value insertion. */
> 
>       if (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &&
>           !could_be_arith(orig, interesting_32[j], 4) &&
>           !could_be_interest(orig, interesting_32[j], 4, 0)) {
5253,5257c5634,5637
<       o_msb = SWAP32(orig) >> 16;
< 
<       if (SWAP32(interesting_32[j]) != interesting_32[j] && 
<           SWAP32(interesting_32[j]) != orig &&
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xffff))) {
---
>       if ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &&
>           !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &&
>           !could_be_arith(orig, SWAP32(interesting_32[j]), 4) &&
>           !could_be_interest(orig, SWAP32(interesting_32[j]), 4, 1)) {
5493c5873
<     u32 use_stacking = 1 << UR(HAVOC_STACK_POW2 + 1);
---
>     u32 use_stacking = 1 << (1 + UR(HAVOC_STACK_POW2));
6017,6034d6396
< static int startswith(const char *str, const char *prefix)
< {
<     return strncmp(prefix, str, strlen(prefix)) == 0;
< }
< 
< 
< static int endswith(const char *str, const char *suffix)
< {
<   if (!str || !suffix)
<     return 0;
<   size_t lenstr = strlen(str);
<   size_t lensuffix = strlen(suffix);
<   if (lensuffix >  lenstr)
<     return 0;
<   return strncmp(str + lenstr - lensuffix, suffix, lensuffix) == 0;
< }
< 
< 
6039,6040d6400
<   sync_times++;
< 
6051,6052d6410
<   int from_which = 0;
< 
6070,6073d6427
<     if (!strcmp(sync_dir, out_dir))
<     {
<       if(!startswith(sd_ent->d_name, "s2e") && !endswith(sd_ent->d_name, "filter") && !startswith(sd_ent->d_name, "traffic")) continue;
<     }
6076,6088d6429
<     if(startswith(sd_ent->d_name, "s2e"))
<     {
<       from_which = S2E_SRC;
<     }
<     else if(startswith(sd_ent->d_name, "traffic"))
<     {
<       from_which = TRA_SRC;
<     }
<     else
<     {
<       from_which = FUZ_SRC;
<     }
< 
6099d6439
<     // qd_synced_path = alloc_printf("%s/.synced/%s", local_out_dir, sd_ent->d_name);
6127c6467
<           sscanf(qd_ent->d_name, CASE_PREFIX "%08u", &syncing_case) != 1 || 
---
>           sscanf(qd_ent->d_name, CASE_PREFIX "%06u", &syncing_case) != 1 || 
6146,6149d6485
<         sync_count++;
<         checked_paths[from_which]++;
< 
< 
6159c6495
<         // ACTF("run_target() 4");
---
> 
6165,6169c6501
<         u8 save_or_not = save_if_interesting(argv, mem, st.st_size, fault);
<         // queued_imported += save_if_interesting(argv, mem, st.st_size, fault);
<         queued_imported += save_or_not;
<         imported_paths[from_which] += save_or_not;
< 
---
>         queued_imported += save_if_interesting(argv, mem, st.st_size, fault);
6197d6528
< 
6250c6581
<   ACTF("Validating target binary: %s...", fname);
---
>   ACTF("Validating target binary...");
6330,6333c6661,6662
<   // if (f_data[0] != 0x7f || memcmp(f_data + 1, "ELF", 3))
<   //   FATAL("Program '%s' is not an ELF binary", target_path);
<   if (f_data[0] != 0x7f || memcmp(f_data + 1, "CGC", 3))
<     FATAL("Program '%s' is not an CGC binary", target_path);
---
>   if (f_data[0] != 0x7f || memcmp(f_data + 1, "ELF", 3))
>     FATAL("Program '%s' is not an ELF binary", target_path);
6376a6706,6722
>   /* Detect persistent & deferred init signatures in the binary. */
> 
>   if (memmem(f_data, f_len, PERSIST_SIG, strlen(PERSIST_SIG) + 1)) {
> 
>     OKF(cPIN "Persistent mode binary detected.");
>     setenv(PERSIST_ENV_VAR, "1", 1);
>     no_var_check = 1;
> 
>   }
> 
>   if (memmem(f_data, f_len, DEFER_SIG, strlen(DEFER_SIG) + 1)) {
> 
>     OKF(cPIN "Deferred forkserver binary detected.");
>     setenv(DEFER_ENV_VAR, "1", 1);
> 
>   }
> 
6412c6758
< /* Check terminal dimensions. */
---
> /* Check if we're on TTY. */
6414c6760
< static void check_terminal(void) {
---
> static void check_if_tty(void) {
6428c6774
<   if (ws.ws_row < 25 || ws.ws_col < 80) {
---
> }
6430,6432d6775
<     SAYF("\n" cLRD "[-] " cRST
<          "Oops, your terminal window seems to be smaller than 80 x 25 characters.\n"
<          "    That's not enough for afl-fuzz to correctly draw its fancy ANSI UI!\n\n"
6434,6436c6777
<          "    Depending on the terminal software you are using, you should be able to\n"
<          "    resize the window by dragging its edges, or to adjust the dimensions in\n"
<          "    the settings menu.\n");
---
> /* Check terminal dimensions after resize. */
6438c6779
<     FATAL("Please resize terminal to 80x25 or more");
---
> static void check_term_size(void) {
6440c6781,6787
<   }
---
>   struct winsize ws;
> 
>   term_too_small = 0;
> 
>   if (ioctl(1, TIOCGWINSZ, &ws)) return;
> 
>   if (ws.ws_row < 25 || ws.ws_col < 80) term_too_small = 1;
6462,6463c6809
<        "  -Q            - use binary-only instrumentation (QEMU mode)\n\n" 
<        "  -L            - maintain logs under QEMU mode\n\n"   
---
>        "  -Q            - use binary-only instrumentation (QEMU mode)\n\n"     
6486,6496d6831
< /* Prepare output fds for qemu_log*/
< static void setup_qemu_log_fd(void)
< {
<   if(!qemu_mode) FATAL("qemu_log only supported under qemu_mode");
< 
<   u8* tmp = alloc_printf("%s/qemu_log", out_dir);
<   qemu_log_fd = open(tmp, O_RDWR|O_CREAT, 0600);
<   if(qemu_log_fd < 0) PFATAL("unalbe to open %s", tmp);
<   ck_free(tmp);
< 
< }
6519a6855,6863
>     out_dir_fd = open(out_dir, O_RDONLY);
> 
> #ifndef __sun
> 
>     if (out_dir_fd < 0 || flock(out_dir_fd, LOCK_EX | LOCK_NB))
>       PFATAL("Unable to flock() output directory.");
> 
> #endif /* !__sun */
> 
6563,6564c6907
<     
<     mkdir(remote_out_dir, 0700);
---
> 
6566d6908
<     // tmp = alloc_printf("%s/.synced/", local_out_dir);
6595d6936
<   // tmp = alloc_printf("%s/plot_data", local_out_dir);
6616d6956
<   // u8* fn = alloc_printf("%s/.cur_input", local_out_dir);
6641c6981
<   if (system("launchctl bslist 2>/dev/null | grep -q '\\.ReportCrash$'")) return;
---
>   if (system("launchctl list 2>/dev/null | grep -q '\\.ReportCrash$'")) return;
6655c6995,6996
<   FATAL("Crash reporter detected");
---
>   if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
>     FATAL("Crash reporter detected");
6682c7023,7024
<     FATAL("Pipe at the beginning of 'core_pattern'");
---
>     if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
>       FATAL("Pipe at the beginning of 'core_pattern'");
6852c7194
<   if (strlen(sync_id) > 64) FATAL("Fuzzer ID too long");
---
>   if (strlen(sync_id) > 32) FATAL("Fuzzer ID too long");
6856,6859c7198
<   if(!sync_dir)
<   {
<     sync_dir = out_dir;
<   }
---
>   sync_dir = out_dir;
6914d7252
<       {
6916,6917d7253
<         // out_file = alloc_printf("%s/.cur_input", local_out_dir);
<       }
6987a7324,7326
> 
> /* Rewrite argv for QEMU. */
> 
6990,6991c7329,7338
<   /* First we should set the target_path to afl-qemu-trace */
<   u8* tmp, *cp, *rsl, *own_copy;
---
>   char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
>   u8 *tmp, *cp, *rsl, *own_copy;
> 
>   memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
> 
>   new_argv[2] = target_path;
>   new_argv[1] = "--";
> 
>   /* Now we need to actually find the QEMU binary to put in argv[0]. */
> 
6993,6994c7340,7342
<   if (tmp) 
<   {
---
> 
>   if (tmp) {
> 
7000,7001c7348,7350
<     target_path =  cp;
<     goto set_tp_done;
---
>     target_path = new_argv[0] = cp;
>     return new_argv;
> 
7006,7007c7355,7357
<   if (rsl) 
<   {
---
> 
>   if (rsl) {
> 
7008a7359
> 
7011,7014c7362,7367
<     if (!access(cp, X_OK)) 
<     {
<       target_path =  cp;
<       goto set_tp_done;
---
> 
>     if (!access(cp, X_OK)) {
> 
>       target_path = new_argv[0] = cp;
>       return new_argv;
> 
7018,7022c7371,7376
<   
<   if (!access(AFL_PATH "/afl-qemu-trace", X_OK)) 
<   {
<     target_path =  ck_strdup(AFL_PATH "/afl-qemu-trace");
<     goto set_tp_done;
---
> 
>   if (!access(BIN_PATH "/afl-qemu-trace", X_OK)) {
> 
>     target_path = new_argv[0] = ck_strdup(BIN_PATH "/afl-qemu-trace");
>     return new_argv;
> 
7026,7033c7380,7387
<          "Oops, unable to find the 'afl-qemu-trace' binary. The binary must be built\n"
<          "    separately by following the instructions in qemu_mode/README.qemu. If you\n"
<          "    already have the binary installed, you may need to specify AFL_PATH in the\n"
<          "    environment.\n\n"
< 
<          "    Of course, even without QEMU, afl-fuzz can still work with binaries that are\n"
<          "    instrumented at compile time with afl-gcc. It is also possible to use it as a\n"
<          "    traditional \"dumb\" fuzzer by specifying '-n' in the command line.\n");
---
>        "Oops, unable to find the 'afl-qemu-trace' binary. The binary must be built\n"
>        "    separately by following the instructions in qemu_mode/README.qemu. If you\n"
>        "    already have the binary installed, you may need to specify AFL_PATH in the\n"
>        "    environment.\n\n"
> 
>        "    Of course, even without QEMU, afl-fuzz can still work with binaries that are\n"
>        "    instrumented at compile time with afl-gcc. It is also possible to use it as a\n"
>        "    traditional \"dumb\" fuzzer by specifying '-n' in the command line.\n");
7036,7052c7390
<   
< set_tp_done:  
<   ACTF("reset target_path is done");
<   char** new_argv = ck_alloc(sizeof(char*) * argc * 4);
<   int i;
<   for(i=0; i<argc; i++)
<   {
<     int th = i * 4;
<     new_argv[th] = target_path;
<     if(is_qemu_log)
<       new_argv[th+1] = "-strace";
<     else
<       new_argv[th+1] = "--";
<     new_argv[th+2] = ck_strdup(argv[i]);
<     new_argv[th+3] = NULL;
<   } 
<   return new_argv;
---
> 
7083,7096d7420
< // void backup_stat(char** stat_vector, int cnt)
< // {
< //   char filepath[] = "/home/vagrant/cc_server/afl_fuzz_stat.txt";
< //   FILE* pFile = fopen(filepath, "w+");
< //   if(pFile != NULL) 
< //   {
< //     int i;
< //     for(i = 0; i < cnt; i++ )
< //     {
< //       fprintf(pFile, "%s\n", stat_vector[i]);
< //     }
< //     fclose(pFile);
< //   }
< // }
7108c7432
<   cksum2paths = kh_init(32);  
---
>   cksum2paths = kh_init(32);
7112,7113c7436
<   SAYF(cCYA "afl-fuzz " cBRI VERSION cRST " (" __DATE__ " " __TIME__ 
<        ") by <lcamtuf@google.com>\n");
---
>   SAYF(cCYA "afl-fuzz " cBRI VERSION cRST " by <lcamtuf@google.com>\n");
7115a7439
>   while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:Q:a")) > 0)
7117,7122d7440
<   // local_out_dir = alloc_printf("/home/vagrant/local_outputs");
<   remote_out_dir = alloc_printf("/home/vagrant/shared_outputs");
< 
<   while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:QLs:")) > 0) 
<   {
<     // ACTF("opt: %c", opt);
7138d7455
<         // local_out_dir = alloc_printf("/home/vagrant/local_outputs");
7149d7465
<         // local_out_dir = alloc_printf("%s/%s", local_out_dir, sync_id);
7151,7156d7466
<         remote_out_dir = alloc_printf("%s/%s", remote_out_dir, sync_id);
<         break;
< 
<       case 's':
<         if(sync_dir) FATAL("Multiple -s options not supported");
<         sync_dir = optarg;
7177,7178c7487,7488
<           if (sscanf(optarg, "%u%c", &exec_tmout, &suffix) < 1)
<             FATAL("Bad syntax used for -t");
---
>           if (sscanf(optarg, "%u%c", &exec_tmout, &suffix) < 1 ||
>               optarg[0] == '-') FATAL("Bad syntax used for -t");
7202,7203c7512,7513
<           if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1)
<             FATAL("Bad syntax used for -m");
---
>           if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1 ||
>               optarg[0] == '-') FATAL("Bad syntax used for -m");
7278,7283d7587
< 
<       case 'L':
< 
<         if(is_qemu_log) FATAL("Multiple -L options not supported");
<         is_qemu_log = 1;
<         break;
7289d7592
<   }
7319c7622
<   check_terminal();
---
>   check_if_tty();
7324a7628
>   setup_post();
7328,7331d7631
< 
<   if(is_qemu_log)
<     setup_qemu_log_fd();
< 
7338a7639,7640
>   if (!timeout_given) find_timeout();
> 
7343,7350c7645
<   stat_vector[0] = out_dir;
<   int _i = 0;
<   while(argv[optind+_i])
<   {
<     check_binary(argv[optind + _i]);
<     stat_vector[_i+1] = argv[optind + _i];
<     _i++;
<   }
---
>   check_binary(argv[optind]);
7353c7648
<  
---
> 
7357,7365c7652
<     use_argv = argv + optind; 
< 
<   int _j;
<   for(_j=0; _j<3; _j++)
<     ACTF("use_argv[%i]: %s", _j , use_argv[_j]);
< 
<   ACTF("use_argv[%i]: 0x%02lx", 3, (unsigned long int)use_argv[3]);
<   
<   ACTF("target_path_: %s", target_path);
---
>     use_argv = argv + optind;
7369,7372d7655
<   // backup_stat(stat_vector, num_of_cbs + 1);
< 
<   // goto stop_fuzzing;
<   
