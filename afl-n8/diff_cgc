45a46
> #include <dlfcn.h>
47d47
< #include <sys/fcntl.h>
58,59d57
< #include <sys/socket.h>
< 
68,81d65
< static int num_of_cbs = 0;
< static char* stat_vector[20];
< 
< #define FUZ_SRC 0
< #define S2E_SRC 1
< #define TRA_SRC 2
< 
< int imported_paths[3] = {0, 0, 0};
< int checked_paths[3] = {0, 0, 0};
< 
< int sync_times = 0;
< int sync_count = 0;
< 
< 
85,86d68
<           // *local_out_dir,
<           *remote_out_dir,
95d76
< 
109a91
>            term_too_small,            /* terminal dimensions too small    */
123,140c105,118
<            dev_urandom_fd,            /* Persistent fd for /dev/urandom   */
<            dev_null_fd;               /* Persistent fd for /dev/null      */
< 
< static s32* qemu_log_fds;                    /*Persistent fd for /tmp/afl_log*/
< 
<            // fsrv_ctl_fd,               /* Fork server control pipe (write) */
<            // fsrv_st_fd;                /* Fork server status pipe (read)   */
< static s32 *fsrv_ctl_fd,
<            *fsrv_st_fd;
< 
< 
< // static s32 forksrv_pid,               /* PID of the fork server           */
<            // child_pid = -1;            /* PID of the fuzzed program        */
< 
< static s32* forksrv_pid = NULL;
< static s32* child_pid = NULL;
< 
< static int* cbs_comm_fds = NULL;
---
>            dev_urandom_fd = -1,       /* Persistent fd for /dev/urandom   */
>            dev_null_fd = -1,          /* Persistent fd for /dev/null      */
>            fsrv_ctl_fd,               /* Fork server control pipe (write) */
>            fsrv_st_fd;                /* Fork server status pipe (read)   */
> 
> static s32 forksrv_pid,               /* PID of the fork server           */
>            child_pid = -1,            /* PID of the fuzzed program        */
>            out_dir_fd = -1;           /* FD of the lock file              */
> 
> static u8* trace_bits;                /* SHM with instrumentation bitmap  */
> 
> static u8  virgin_bits[MAP_SIZE],     /* Regions yet untouched by fuzzing */
>            virgin_hang[MAP_SIZE],     /* Bits we haven't seen in hangs    */
>            virgin_crash[MAP_SIZE];    /* Bits we haven't seen in crashes  */
142,155c120
< static int is_qemu_log = 0;
< 
< // static u8* trace_bits;                /* SHM with instrumentation bitmap  */
< static u8** trace_bits;
< 
< // static u8  virgin_bits[MAP_SIZE],     /* Regions yet untouched by fuzzing */
< //            virgin_hang[MAP_SIZE],     /* Bits we haven't seen in hangs    */
< //            virgin_crash[MAP_SIZE];    /* Bits we haven't seen in crashes  */
< static u8** virgin_bits;
< static u8** virgin_hang;
< static u8** virgin_crash;
< 
< // static s32 shm_id;                    /* ID of the SHM region             */
< static s32* shm_id;
---
> static s32 shm_id;                    /* ID of the SHM region             */
184,185c149
<            first_crash_time = 0,      /* Add for cgc                      */
<            last_crash_time = 0,       /* Time for most recent crash (ms)  */
---
>            last_crash_time,           /* Time for most recent crash (ms)  */
214c178
< static u32 rand_cnt = RESEED_RNG;     /* Random number counter            */
---
> static u32 rand_cnt;                  /* Random number counter            */
252,253c216,217
<   struct queue_entry *next;             /* Next element, if any             */
<                    // *next_100         /* 100 elements ahead               */
---
>   struct queue_entry *next//,           /* Next element, if any             */
>                    /* *next_100*/;       /* 100 elements ahead               */
262,264c226,227
< // static struct queue_entry*
< //   top_rated[MAP_SIZE];                /* Top entries for bitmap bytes     */
< static struct queue_entry** top_rated;
---
> static struct queue_entry*
>   top_rated[MAP_SIZE];                /* Top entries for bitmap bytes     */
277a241,242
> static u8* (*post_handler)(u8* buf, u32* len);
> 
785d749
<   // fname = alloc_printf("%s/fuzz_bitmap", local_out_dir);
790,797c754
<   u8* virgin_bits_one = ck_alloc(sizeof(u8) * MAP_SIZE * num_of_cbs);
<   int cb_id;
<   for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<   {
<     u8* ptr = virgin_bits_one + MAP_SIZE * cb_id;
<     memcpy(ptr, virgin_bits[cb_id], MAP_SIZE);
<   }
<   ck_write(fd, virgin_bits_one, MAP_SIZE * num_of_cbs, fname);
---
>   ck_write(fd, virgin_bits, MAP_SIZE, fname);
799d755
<   ck_free(virgin_bits_one);
810d765
<   u8* virgin_bits_one = ck_alloc(sizeof(u8) * MAP_SIZE * num_of_cbs);
815c770
<   ck_read(fd, virgin_bits_one, MAP_SIZE * num_of_cbs, fname);
---
>   ck_read(fd, virgin_bits, MAP_SIZE, fname);
817,823d771
<   int cb_id;
<   for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<   {
<     u8* ptr = virgin_bits_one + MAP_SIZE * cb_id;
<     memcpy(virgin_bits[cb_id], ptr, MAP_SIZE);
<   }
<   ck_free(virgin_bits_one);
840,844c788
< static inline u8 has_new_bits(u8** virgin_map) {
<   int cb_id;
<   u8 ret = 0;
<   for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<   {
---
> static inline u8 has_new_bits(u8* virgin_map) {
848,849c792,793
<     u64* current = (u64*)trace_bits[cb_id];
<     u64* virgin  = (u64*)virgin_map[cb_id];
---
>   u64* current = (u64*)trace_bits;
>   u64* virgin  = (u64*)virgin_map;
851c795
<     u32  i = (MAP_SIZE >> 3);
---
>   u32  i = (MAP_SIZE >> 3);
855,856c799,800
<     u32* current = (u32*)trace_bits[cb_id];
<     u32* virgin  = (u32*)virgin_map[cb_id];
---
>   u32* current = (u32*)trace_bits;
>   u32* virgin  = (u32*)virgin_map;
858c802
<     u32  i = (MAP_SIZE >> 2);
---
>   u32  i = (MAP_SIZE >> 2);
862c806
<     // u8   ret = 0;
---
>   u8   ret = 0;
864c808
<     while (i--) {
---
>   while (i--) {
868,869c812,813
<       u64 cur = *current;
<       u64 vir = *virgin;
---
>     u64 cur = *current;
>     u64 vir = *virgin;
873,874c817,818
<       u32 cur = *current;
<       u32 vir = *virgin;
---
>     u32 cur = *current;
>     u32 vir = *virgin;
878,879c822,823
<       /* Optimize for *current == ~*virgin, since this will almost always be the
<          case. */
---
>     /* Optimize for *current == ~*virgin, since this will almost always be the
>        case. */
881c825
<       if (cur & vir) {
---
>     if (cur & vir) {
883c827
<         if (ret < 2) {
---
>       if (ret < 2) {
885,886c829,830
<           /* This trace did not have any new bytes yet; see if there's any
<              current[] byte that is non-zero when virgin[] is 0xff. */
---
>         /* This trace did not have any new bytes yet; see if there's any
>            current[] byte that is non-zero when virgin[] is 0xff. */
890,898c834,842
<           if (((cur & FFL(0)) && (vir & FFL(0)) == FFL(0)) ||
<               ((cur & FFL(1)) && (vir & FFL(1)) == FFL(1)) ||
<               ((cur & FFL(2)) && (vir & FFL(2)) == FFL(2)) ||
<               ((cur & FFL(3)) && (vir & FFL(3)) == FFL(3)) ||
<               ((cur & FFL(4)) && (vir & FFL(4)) == FFL(4)) ||
<               ((cur & FFL(5)) && (vir & FFL(5)) == FFL(5)) ||
<               ((cur & FFL(6)) && (vir & FFL(6)) == FFL(6)) ||
<               ((cur & FFL(7)) && (vir & FFL(7)) == FFL(7))) ret = 2;
<           else ret = 1;
---
>         if (((cur & FFL(0)) && (vir & FFL(0)) == FFL(0)) ||
>             ((cur & FFL(1)) && (vir & FFL(1)) == FFL(1)) ||
>             ((cur & FFL(2)) && (vir & FFL(2)) == FFL(2)) ||
>             ((cur & FFL(3)) && (vir & FFL(3)) == FFL(3)) ||
>             ((cur & FFL(4)) && (vir & FFL(4)) == FFL(4)) ||
>             ((cur & FFL(5)) && (vir & FFL(5)) == FFL(5)) ||
>             ((cur & FFL(6)) && (vir & FFL(6)) == FFL(6)) ||
>             ((cur & FFL(7)) && (vir & FFL(7)) == FFL(7))) ret = 2;
>         else ret = 1;
902,906c846,850
<           if (((cur & FF(0)) && (vir & FF(0)) == FF(0)) ||
<               ((cur & FF(1)) && (vir & FF(1)) == FF(1)) ||
<               ((cur & FF(2)) && (vir & FF(2)) == FF(2)) ||
<               ((cur & FF(3)) && (vir & FF(3)) == FF(3))) ret = 2;
<           else ret = 1;
---
>         if (((cur & FF(0)) && (vir & FF(0)) == FF(0)) ||
>             ((cur & FF(1)) && (vir & FF(1)) == FF(1)) ||
>             ((cur & FF(2)) && (vir & FF(2)) == FF(2)) ||
>             ((cur & FF(3)) && (vir & FF(3)) == FF(3))) ret = 2;
>         else ret = 1;
910,913d853
<         }
< 
<         *virgin = vir & ~cur;
< 
916,917c856
<       current++;
<       virgin++;
---
>       *virgin = vir & ~cur;
919a859,862
> 
>     current++;
>     virgin++;
> 
932c875
< static u32 count_bits(u8** mem) {
---
> static u32 count_bits(u8* mem) {
934,940c877,879
<   int cb_id;
<   u32 ret = 0;
<   for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<   {
<     u32* ptr = (u32*)(mem[cb_id]);
<     u32  i   = (MAP_SIZE >> 2);
<     // u32  ret = 0;
---
>   u32* ptr = (u32*)mem;
>   u32  i   = (MAP_SIZE >> 2);
>   u32  ret = 0;
942c881
<     while (i--) {
---
>   while (i--) {
944c883
<       u32 v = *(ptr++);
---
>     u32 v = *(ptr++);
946,947c885,886
<       /* This gets called on the inverse, virgin bitmap; optimize for sparse
<          data. */
---
>     /* This gets called on the inverse, virgin bitmap; optimize for sparse
>        data. */
949,952c888,891
<       if (v == 0xffffffff) {
<         ret += 32;
<         continue;
<       }
---
>     if (v == 0xffffffff) {
>       ret += 32;
>       continue;
>     }
954,956c893,895
<       v -= ((v >> 1) & 0x55555555);
<       v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
<       ret += (((v + (v >> 4)) & 0xF0F0F0F) * 0x01010101) >> 24;
---
>     v -= ((v >> 1) & 0x55555555);
>     v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
>     ret += (((v + (v >> 4)) & 0xF0F0F0F) * 0x01010101) >> 24;
958d896
<     }
959a898
> 
969c908
< static u32 count_bytes(u8** mem) {
---
> static u32 count_bytes(u8* mem) {
971,987c910,922
<   int j;
<   u32 ret = 0;
<   for(j=0; j<num_of_cbs; j++)
<   {
<     u32* ptr = (u32*)(mem[j]);
<     u32  i   = (MAP_SIZE >> 2);
<     // u32  ret = 0;
< 
<     while (i--) {
< 
<       u32 v = *(ptr++);
< 
<       if (!v) continue;
<       if (v & FF(0)) ret++;
<       if (v & FF(1)) ret++;
<       if (v & FF(2)) ret++;
<       if (v & FF(3)) ret++;
---
>   u32* ptr = (u32*)mem;
>   u32  i   = (MAP_SIZE >> 2);
>   u32  ret = 0;
> 
>   while (i--) {
> 
>     u32 v = *(ptr++);
> 
>     if (!v) continue;
>     if (v & FF(0)) ret++;
>     if (v & FF(1)) ret++;
>     if (v & FF(2)) ret++;
>     if (v & FF(3)) ret++;
989d923
<     }
1000c934
< static u32 count_non_255_bytes(u8** mem) {
---
> static u32 count_non_255_bytes(u8* mem) {
1002,1021c936,951
<   int j;
<   u32 ret = 0;
<   for(j=0; j<num_of_cbs; j++)
<   {
<     u32* ptr = (u32*)(mem[j]);
<     u32  i   = (MAP_SIZE >> 2);
<     // u32  ret = 0;
< 
<     while (i--) {
< 
<       u32 v = *(ptr++);
< 
<       /* This is called on the virgin bitmap, so optimize for the most likely
<          case. */
< 
<       if (v == 0xffffffff) continue;
<       if ((v & FF(0)) != FF(0)) ret++;
<       if ((v & FF(1)) != FF(1)) ret++;
<       if ((v & FF(2)) != FF(2)) ret++;
<       if ((v & FF(3)) != FF(3)) ret++;
---
>   u32* ptr = (u32*)mem;
>   u32  i   = (MAP_SIZE >> 2);
>   u32  ret = 0;
> 
>   while (i--) {
> 
>     u32 v = *(ptr++);
> 
>     /* This is called on the virgin bitmap, so optimize for the most likely
>        case. */
> 
>     if (v == 0xffffffff) continue;
>     if ((v & FF(0)) != FF(0)) ret++;
>     if ((v & FF(1)) != FF(1)) ret++;
>     if ((v & FF(2)) != FF(2)) ret++;
>     if ((v & FF(3)) != FF(3)) ret++;
1023d952
<     }
1055c984
< static void simplify_trace(u64** mem_array) {
---
> static void simplify_trace(u64* mem) {
1057,1078c986
<   int j;
<   u64* mem;
<   for(j=0; j<num_of_cbs; j++)
<   {
<     u32 i = MAP_SIZE >> 3;
<     mem = mem_array[j];
<     while (i--) {
< 
<       /* Optimize for sparse bitmaps. */
< 
<       if (*mem) {
< 
<         u8* mem8 = (u8*)mem;
< 
<         mem8[0] = simplify_lookup[mem8[0]];
<         mem8[1] = simplify_lookup[mem8[1]];
<         mem8[2] = simplify_lookup[mem8[2]];
<         mem8[3] = simplify_lookup[mem8[3]];
<         mem8[4] = simplify_lookup[mem8[4]];
<         mem8[5] = simplify_lookup[mem8[5]];
<         mem8[6] = simplify_lookup[mem8[6]];
<         mem8[7] = simplify_lookup[mem8[7]];
---
>   u32 i = MAP_SIZE >> 3;
1080c988
<       } else *mem = 0x0101010101010101ULL;
---
>   while (i--) {
1082c990,1007
<       mem++;
---
>     /* Optimize for sparse bitmaps. */
> 
>     if (*mem) {
> 
>       u8* mem8 = (u8*)mem;
> 
>       mem8[0] = simplify_lookup[mem8[0]];
>       mem8[1] = simplify_lookup[mem8[1]];
>       mem8[2] = simplify_lookup[mem8[2]];
>       mem8[3] = simplify_lookup[mem8[3]];
>       mem8[4] = simplify_lookup[mem8[4]];
>       mem8[5] = simplify_lookup[mem8[5]];
>       mem8[6] = simplify_lookup[mem8[6]];
>       mem8[7] = simplify_lookup[mem8[7]];
> 
>     } else *mem = 0x0101010101010101ULL;
> 
>     mem++;
1084d1008
<     }
1091c1015
< static void simplify_trace(u32** mem_array) {
---
> static void simplify_trace(u32* mem) {
1093,1094c1017
<   int j;
<   u32* mem;
---
>   u32 i = MAP_SIZE >> 2;
1096,1100c1019
<   for(j=0; j<num_of_cbs; j++)
<   {
<     u32 i = MAP_SIZE >> 2;
<     mem = mem_array[j];
<     while (i--) {
---
>   while (i--) {
1102c1021
<       /* Optimize for sparse bitmaps. */
---
>     /* Optimize for sparse bitmaps. */
1104c1023
<       if (*mem) {
---
>     if (*mem) {
1106c1025
<         u8* mem8 = (u8*)mem;
---
>       u8* mem8 = (u8*)mem;
1108,1111c1027,1030
<         mem8[0] = simplify_lookup[mem8[0]];
<         mem8[1] = simplify_lookup[mem8[1]];
<         mem8[2] = simplify_lookup[mem8[2]];
<         mem8[3] = simplify_lookup[mem8[3]];
---
>       mem8[0] = simplify_lookup[mem8[0]];
>       mem8[1] = simplify_lookup[mem8[1]];
>       mem8[2] = simplify_lookup[mem8[2]];
>       mem8[3] = simplify_lookup[mem8[3]];
1113c1032
<       } else *mem = 0x01010101;
---
>     } else *mem = 0x01010101;
1115,1116c1034
<       mem++;
<     }
---
>     mem++;
1141c1059
< static inline void classify_counts(u64** mem_array) {
---
> static inline void classify_counts(u64* mem) {
1143,1164c1061
<   int j;
<   for(j=0; j<num_of_cbs; j++)
<   {
<     u32 i = MAP_SIZE >> 3;
<     u64* mem = mem_array[j];
< 
<     while (i--) {
< 
<       /* Optimize for sparse bitmaps. */
< 
<       if (*mem) {
< 
<         u8* mem8 = (u8*)mem;
< 
<         mem8[0] = count_class_lookup[mem8[0]];
<         mem8[1] = count_class_lookup[mem8[1]];
<         mem8[2] = count_class_lookup[mem8[2]];
<         mem8[3] = count_class_lookup[mem8[3]];
<         mem8[4] = count_class_lookup[mem8[4]];
<         mem8[5] = count_class_lookup[mem8[5]];
<         mem8[6] = count_class_lookup[mem8[6]];
<         mem8[7] = count_class_lookup[mem8[7]];
---
>   u32 i = MAP_SIZE >> 3;
1166c1063,1067
<       }
---
>   while (i--) {
> 
>     /* Optimize for sparse bitmaps. */
> 
>     if (*mem) {
1168c1069,1078
<       mem++;
---
>       u8* mem8 = (u8*)mem;
> 
>       mem8[0] = count_class_lookup[mem8[0]];
>       mem8[1] = count_class_lookup[mem8[1]];
>       mem8[2] = count_class_lookup[mem8[2]];
>       mem8[3] = count_class_lookup[mem8[3]];
>       mem8[4] = count_class_lookup[mem8[4]];
>       mem8[5] = count_class_lookup[mem8[5]];
>       mem8[6] = count_class_lookup[mem8[6]];
>       mem8[7] = count_class_lookup[mem8[7]];
1170a1081,1083
> 
>     mem++;
> 
1177c1090
< static inline void classify_counts(u32** mem_array) {
---
> static inline void classify_counts(u32* mem) {
1179,1184c1092
<   int j;
<   for(j=0; j<num_of_cbs; j++)
<   {
<     u32 i = MAP_SIZE >> 2;
<     u32* mem = mem_array[j];
<     while (i--) {
---
>   u32 i = MAP_SIZE >> 2;
1186c1094
<       /* Optimize for sparse bitmaps. */
---
>   while (i--) {
1188c1096
<       if (*mem) {
---
>     /* Optimize for sparse bitmaps. */
1190c1098
<         u8* mem8 = (u8*)mem;
---
>     if (*mem) {
1192,1195c1100
<         mem8[0] = count_class_lookup[mem8[0]];
<         mem8[1] = count_class_lookup[mem8[1]];
<         mem8[2] = count_class_lookup[mem8[2]];
<         mem8[3] = count_class_lookup[mem8[3]];
---
>       u8* mem8 = (u8*)mem;
1197,1199c1102,1105
<       }
< 
<       mem++;
---
>       mem8[0] = count_class_lookup[mem8[0]];
>       mem8[1] = count_class_lookup[mem8[1]];
>       mem8[2] = count_class_lookup[mem8[2]];
>       mem8[3] = count_class_lookup[mem8[3]];
1201a1108,1110
> 
>     mem++;
> 
1212,1217c1121,1122
<   int i;
<   for(i=0; i<num_of_cbs; i++)
<   {
<     if(shm_id[i] != -1)
<       shmctl(shm_id[i], IPC_RMID, NULL);
<   }
---
> 
>   shmctl(shm_id, IPC_RMID, NULL);
1226c1131,1138
< static void minimize_bits(u8* dst, u8** src_array) {
---
> static void minimize_bits(u8* dst, u8* src) {
> 
>   u32 i = 0;
> 
>   while (i < MAP_SIZE) {
> 
>     if (*(src++)) dst[i >> 3] |= 1 << (i & 7);
>     i++;
1228,1239d1139
<   int j;
<   u8* dst_p;
<   u8* src;
<   for(j=0; j<num_of_cbs; j++)
<   {
<     dst_p = dst + (MAP_SIZE >> 3) * j;
<     src = src_array[j];
<     u32 i = 0;
<     while (i < MAP_SIZE) {
<       if (*(src++)) dst_p[i >> 3] |= 1 << (i & 7);
<       i++;
<     }
1240a1141
> 
1255d1155
< 
1258c1158
<   u32 paths = getPaths(q->exec_cksum);  
---
>   u32 paths = getPaths(q->exec_cksum);
1259a1160,1161
>   
>   for (i = 0; i < MAP_SIZE; i++)
1261,1271c1163
<   /* For every byte set in trace_bits[], see if there is a previous winner,
<      and how it compares to us. */
<   int cb_id; 
<   for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<   {
<     u32 start = 0 + cb_id * MAP_SIZE;
<     u32 end = MAP_SIZE + cb_id * MAP_SIZE;
<     for (i = start; i < end; i++)
<     {  
<       if (trace_bits[cb_id][i - start]) {
<         if (top_rated[i]) {
---
>     if (trace_bits[i]) {
1273,1274c1165
<           /* Faster-executing or smaller test cases are favored. */
<          // if (fav_factor > top_rated[i]->exec_us * top_rated[i]->len) continue;
---
>        if (top_rated[i]) {
1287,1289c1178,1180
<    
<           /* Looks like we're going to win. Decrease ref count for the
<           previous winner, discard its trace_bits[] if necessary. */
---
>          
>          /* Looks like we're going to win. Decrease ref count for the
>             previous winner, discard its trace_bits[] if necessary. */
1291,1294c1182,1185
<           if (!--top_rated[i]->tc_ref) {
<             ck_free(top_rated[i]->trace_mini);
<             top_rated[i]->trace_mini = 0;
<           }
---
>          if (!--top_rated[i]->tc_ref) {
>            ck_free(top_rated[i]->trace_mini);
>            top_rated[i]->trace_mini = 0;
>          }
1296,1297c1187
<         }
<         /* Insert ourselves as the new winner. */
---
>        }
1299,1300c1189
<         top_rated[i] = q;
<         q->tc_ref++;
---
>        /* Insert ourselves as the new winner. */
1302,1306c1191,1192
<         if (!q->trace_mini) {
<           q->trace_mini = ck_alloc((num_of_cbs * MAP_SIZE) >> 3);
<           minimize_bits(q->trace_mini, trace_bits);
<         }
<         score_changed = 1;
---
>        top_rated[i] = q;
>        q->tc_ref++;
1308,1310c1194,1201
<       }
<     }
<   }
---
>        if (!q->trace_mini) {
>          q->trace_mini = ck_alloc(MAP_SIZE >> 3);
>          minimize_bits(q->trace_mini, trace_bits);
>        }
> 
>        score_changed = 1;
> 
>      }
1324,1328c1215
<   // static u8 temp_v[MAP_SIZE >> 3];
<   static u8* temp_v = NULL;
<   if(!temp_v)
<     temp_v = ck_alloc((MAP_SIZE * num_of_cbs) >> 3);
< 
---
>   static u8 temp_v[MAP_SIZE >> 3];
1335c1222
<   memset(temp_v, 255, (MAP_SIZE * num_of_cbs) >> 3);
---
>   memset(temp_v, 255, MAP_SIZE >> 3);
1351c1238
<   for (i = 0; i < MAP_SIZE * num_of_cbs; i++)
---
>   for (i = 0; i < MAP_SIZE; i++)
1354c1241
<       u32 j = (MAP_SIZE * num_of_cbs) >> 3;
---
>       u32 j = MAP_SIZE >> 3;
1365c1252
<       // if (!top_rated[i]->was_fuzzed) pending_favored++;
---
>       //if (!top_rated[i]->was_fuzzed) pending_favored++;
1367d1253
< 
1370,1377c1256,1261
<   // ck_free(temp_v);
< 
<   // q = queue;
< 
<   // while (q) {
<   //   mark_as_redundant(q, !q->favored);
<   //   q = q->next;
<   // }
---
>   //q = queue;
>   //
>   //while (q) {
>   //  mark_as_redundant(q, !q->favored);
>   //  q = q->next;
>   //}
1386,1396c1270,1272
<   shm_id = (s32*)ck_alloc(sizeof(s32) * num_of_cbs);
<   virgin_bits = (u8**)ck_alloc(sizeof(u8*) * num_of_cbs);
<   virgin_hang = (u8**)ck_alloc(sizeof(u8*) * num_of_cbs);
<   virgin_crash = (u8**)ck_alloc(sizeof(u8*) * num_of_cbs);
<   trace_bits = (u8**)ck_alloc(sizeof(u8*) * num_of_cbs);
< 
<   int i;
<   for(i=0; i<num_of_cbs; i++)
<     shm_id[i] = -1;
<   
<   atexit(remove_shm);
---
>   u8* shm_str;
> 
>   if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE);
1398,1399c1274,1275
<   for(i=0; i<num_of_cbs; i++)
<   { 
---
>   memset(virgin_hang, 255, MAP_SIZE);
>   memset(virgin_crash, 255, MAP_SIZE);
1401,1403c1277
<     virgin_bits[i] = ck_alloc(MAP_SIZE);
<     virgin_hang[i] = ck_alloc(MAP_SIZE);
<     virgin_crash[i] = ck_alloc(MAP_SIZE);
---
>   shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);
1405c1279
<     if (!in_bitmap) memset(virgin_bits[i], 255, MAP_SIZE);
---
>   if (shm_id < 0) PFATAL("shmget() failed");
1407,1408c1281,1288
<     memset(virgin_hang[i], 255, MAP_SIZE);
<     memset(virgin_crash[i], 255, MAP_SIZE);
---
>   atexit(remove_shm);
> 
>   shm_str = alloc_printf("%d", shm_id);
> 
>   /* If somebody is asking us to fuzz instrumented binaries in dumb mode,
>      we don't want them to detect instrumentation, since we won't be sending
>      fork server commands. This should be replaced with better auto-detection
>      later on, perhaps? */
1410c1290,1291
<     shm_id[i] = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);
---
>   if (dumb_mode != 1)
>     setenv(SHM_ENV_VAR, shm_str, 1);
1412c1293
<     if (shm_id[i] < 0) PFATAL("shmget() failed for %i", i);
---
>   ck_free(shm_str);
1414c1295
<     trace_bits[i] = shmat(shm_id[i], NULL, 0);
---
>   trace_bits = shmat(shm_id, NULL, 0);
1416,1419c1297,1324
<     if (!trace_bits[i]) PFATAL("shmat() failed");
<   }
<   // u8* shm_str;
<   // shm_str = alloc_printf("%d", shm_id[i]);
---
>   if (!trace_bits) PFATAL("shmat() failed");
> 
> }
> 
> 
> /* Load postprocessor, if available. */
> 
> static void setup_post(void) {
> 
>   void* dh;
>   u8* fn = getenv("AFL_POST_LIBRARY");
>   u32 tlen = 6;
> 
>   if (!fn) return;
> 
>   ACTF("Loading postprocessor from '%s'...", fn);
> 
>   dh = dlopen(fn, RTLD_NOW);
>   if (!dh) FATAL("%s", dlerror());
> 
>   post_handler = dlsym(dh, "afl_postprocess");
>   if (!post_handler) FATAL("Symbol 'afl_postprocess' not found.");
> 
>   /* Do a quick test. It's better to segfault now than later =) */
> 
>   post_handler("hello", &tlen);
> 
>   OKF("Postprocessor installed successfully.");
1421,1444d1325
<   //    If somebody is asking us to fuzz instrumented binaries in dumb mode,
<   //      we don't want them to detect instrumentation, since we won't be sending
<   //      fork server commands. This should be replaced with better auto-detection
<   //      later on, perhaps? 
< 
<   // if (dumb_mode != 1)
<   //   setenv(SHM_ENV_VAR, shm_str, 1);
< 
<   // ck_free(shm_str);
<   for(i=0; i< num_of_cbs; i++)
<   {
<     ACTF("shm_id[%i]: %i", i, (int)shm_id[i]);
< #ifdef __x86_64__
<     ACTF("trace_bits[%i] addr: 0x%016lx", i, (unsigned long)trace_bits[i]);
<     ACTF("virgin_bits[%i] addr: 0x%016lx", i, (unsigned long)virgin_bits[i]);
<     ACTF("virgin_hang[%i] addr: 0x%016lx", i, (unsigned long)virgin_hang[i]);
<     ACTF("virgin_crash[%i] addr: 0x%016lx", i, (unsigned long)virgin_crash[i]);
< #else
<     ACTF("trace_bits[%i] addr: 0x%08x", i, (unsigned int)trace_bits[i]);
<     ACTF("virgin_bits[%i] addr: 0x%08x", i, (unsigned int)virgin_bits[i]);
<     ACTF("virgin_hang[%i] addr: 0x%08x", i, (unsigned int)virgin_hang[i]);
<     ACTF("virgin_crash[%i] addr: 0x%08x", i, (unsigned int)virgin_crash[i]);
< #endif /* ^__x86_64__ */
<   }
1561a1443,1579
> /* Read extras from a file, sort by size. */
> 
> static void load_extras_file(u8* fname, u32* min_len, u32* max_len,
>                              u32 dict_level) {
> 
>   FILE* f;
>   u8  buf[MAX_LINE];
>   u8  *lptr;
>   u32 cur_line = 0;
> 
>   f = fopen(fname, "r");
> 
>   if (!f) PFATAL("Unable to open '%s'", fname);
> 
>   while ((lptr = fgets(buf, MAX_LINE, f))) {
> 
>     u8 *rptr, *wptr;
>     u32 klen = 0;
> 
>     cur_line++;
> 
>     /* Trim on left and right. */
> 
>     while (isspace(*lptr)) lptr++;
> 
>     rptr = lptr + strlen(lptr) - 1;
>     while (rptr >= lptr && isspace(*rptr)) rptr--;
>     rptr++;
>     *rptr = 0;
> 
>     /* Skip empty lines and comments. */
> 
>     if (!*lptr || *lptr == '#') continue;
> 
>     /* All other lines must end with '"', which we can consume. */
> 
>     rptr--;
> 
>     if (rptr < lptr || *rptr != '"')
>       FATAL("Malformed name=\"value\" pair in line %u.", cur_line);
> 
>     *rptr = 0;
> 
>     /* Skip alphanumerics and dashes (label). */
> 
>     while (isalnum(*lptr) || *lptr == '_') lptr++;
> 
>     /* If @number follows, parse that. */
> 
>     if (*lptr == '@') {
> 
>       lptr++;
>       if (atoi(lptr) > dict_level) continue;
>       while (isdigit(*lptr)) lptr++;
> 
>     }
> 
>     /* Skip whitespace and = signs. */
> 
>     while (isspace(*lptr) || *lptr == '=') lptr++;
> 
>     /* Consume opening '"'. */
> 
>     if (*lptr != '"')
>       FATAL("Malformed name=\"keyword\" pair in line %u.", cur_line);
> 
>     lptr++;
> 
>     if (!*lptr) FATAL("Empty keyword in line %u.", cur_line);
> 
>     /* Okay, let's allocate memory and copy data between "...", handling
>        \xNN escaping, \\, and \". */
> 
>     extras = ck_realloc_block(extras, (extras_cnt + 1) *
>                sizeof(struct extra_data));
> 
>     wptr = extras[extras_cnt].data = ck_alloc(rptr - lptr);
> 
>     while (*lptr) {
> 
>       char* hexdigits = "0123456789abcdef";
> 
>       switch (*lptr) {
> 
>         case 1 ... 31:
>         case 128 ... 255:
>           FATAL("Non-printable characters in line %u.", cur_line);
> 
>         case '\\':
> 
>           lptr++;
> 
>           if (*lptr == '\\' || *lptr == '"') {
>             *(wptr++) = *(lptr++);
>             klen++;
>             break;
>           }
> 
>           if (*lptr != 'x' || !isxdigit(lptr[1]) || !isxdigit(lptr[2]))
>             FATAL("Invalid escaping (not \\xNN) in line %u.", cur_line);
> 
>           *(wptr++) =
>             ((strchr(hexdigits, tolower(lptr[1])) - hexdigits) << 4) |
>             (strchr(hexdigits, tolower(lptr[2])) - hexdigits);
> 
>           lptr += 3;
>           klen++;
> 
>           break;
> 
>         default:
> 
>           *(wptr++) = *(lptr++);
>           klen++;
> 
>       }
> 
>     }
> 
>     extras[extras_cnt].len = klen;
> 
>     if (extras[extras_cnt].len > MAX_DICT_FILE)
>       FATAL("Keyword too big in line %u (%s, limit is %s)", cur_line,
>             DMS(klen), DMS(MAX_DICT_FILE));
> 
>     if (*min_len > klen) *min_len = klen;
>     if (*max_len < klen) *max_len = klen;
> 
>     extras_cnt++;
> 
>   }
> 
>   fclose(f);
> 
> }
> 
> 
1568c1586,1591
<   u32 min_len = MAX_DICT_FILE, max_len = 0;
---
>   u32 min_len = MAX_DICT_FILE, max_len = 0, dict_level = 0;
>   u8* x;
> 
>   /* If the name ends with @, extract level and continue. */
> 
>   if ((x = strchr(dir, '@'))) {
1570c1593,1598
<   ACTF("Loading extra dictionary from '%s'...", dir);
---
>     *x = 0;
>     dict_level = atoi(x + 1);
> 
>   }
> 
>   ACTF("Loading extra dictionary from '%s' (level %u)...", dir, dict_level);
1574c1602,1613
<   if (!d) PFATAL("Unable to open '%s'", dir);
---
>   if (!d) {
> 
>     if (errno == ENOTDIR) {
>       load_extras_file(dir, &min_len, &max_len, dict_level);
>       goto check_and_sort;
>     }
> 
>     PFATAL("Unable to open '%s'", dir);
> 
>   }
> 
>   if (x) FATAL("Dictinary levels not supported for directories.");
1619a1659,1661
> 
> check_and_sort:
> 
1637a1680,1681
> 
> 
1765c1809
<     u8* fn = alloc_printf("%s/queue/.state/auto_extras/auto_%08u", out_dir, i);
---
>     u8* fn = alloc_printf("%s/queue/.state/auto_extras/auto_%06u", out_dir, i);
1791c1835
<     u8* fn = alloc_printf("%s/.state/auto_extras/auto_%08u", in_dir, i);
---
>     u8* fn = alloc_printf("%s/.state/auto_extras/auto_%06u", in_dir, i);
1843,1853d1886
< /*CGC now set up fds for communication between multiple CBs*/
< static void init_cbs_comm_fds()
< {
<   cbs_comm_fds = ck_alloc(sizeof(int) * num_of_cbs * 2);
<   int i;
<   for(i=0; i<num_of_cbs; i++)
<   {
<     if(0 != socketpair(AF_UNIX, SOCK_STREAM, 0, cbs_comm_fds + 2 * i))
<       PFATAL("Cannot create socket");
<   }
< }
1866c1899
<   // int st_pipe[2], ctl_pipe[2];
---
>   int st_pipe[2], ctl_pipe[2];
1870,1883c1903
<   forksrv_pid = ck_alloc(sizeof(s32) * num_of_cbs);
<   child_pid   = ck_alloc(sizeof(s32) * num_of_cbs);
<   fsrv_ctl_fd = ck_alloc(sizeof(s32) * num_of_cbs);
<   fsrv_st_fd  = ck_alloc(sizeof(s32) * num_of_cbs);
< 
<   cbs_comm_fds = ck_alloc(sizeof(int) * (num_of_cbs - 1) * 2);
< 
<   int i;
<   for(i=0; i<num_of_cbs; i++)
<   {
<     forksrv_pid[i] = -1;
<     child_pid[i] = -1;
<   }
< 
---
>   ACTF("Spinning up the fork server...");
1885,1888c1905
<   for(i=0; i<num_of_cbs; i++)
<   {
<     child_timed_out = 0;
<     int st_pipe[2], ctl_pipe[2];
---
>   if (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL("pipe() failed");
1890c1907
<     ACTF("Spinning up the fork server for cb_%02i...", i);
---
>   forksrv_pid = fork();
1892c1909
<     if (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL("pipe() failed for cb_%02i", i);
---
>   if (forksrv_pid < 0) PFATAL("fork() failed");
1894c1911
<     forksrv_pid[i] = fork();
---
>   if (!forksrv_pid) {
1896c1913
<     if (forksrv_pid[i] < 0) PFATAL("fork() failed for cb_%02i", i);
---
>     struct rlimit r;
1898c1915,1916
<     if (!forksrv_pid[i]) {
---
>     /* Umpf. On OpenBSD, the default fd limit for root users is set to
>        soft 128. Let's try to fix that... */
1900c1918
<       struct rlimit r;
---
>     if (!getrlimit(RLIMIT_NOFILE, &r) && r.rlim_cur < FORKSRV_FD + 2) {
1902,1903c1920,1921
<       /* Umpf. On OpenBSD, the default fd limit for root users is set to
<         soft 128. Let's try to fix that... */
---
>       r.rlim_cur = FORKSRV_FD + 2;
>       setrlimit(RLIMIT_NOFILE, &r); /* Ignore errors */
1905c1923
<       if (!getrlimit(RLIMIT_NOFILE, &r) && r.rlim_cur < FORKSRV_FD + 2) {
---
>     }
1907,1908c1925
<         r.rlim_cur = FORKSRV_FD + 2;
<         setrlimit(RLIMIT_NOFILE, &r); /* Ignore errors */
---
>     if (mem_limit) {
1910,1914c1927
<       }
< 
<       if (mem_limit) {
< 
<         r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;
---
>       r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;
1918c1931
<         setrlimit(RLIMIT_AS, &r); /* Ignore errors */
---
>       setrlimit(RLIMIT_AS, &r); /* Ignore errors */
1922,1924c1935,1937
<         /* This takes care of OpenBSD, which doesn't have RLIMIT_AS, but
<            according to reliable sources, RLIMIT_DATA covers anonymous
<            maps - so we should be getting good protection against OOM bugs. */
---
>       /* This takes care of OpenBSD, which doesn't have RLIMIT_AS, but
>          according to reliable sources, RLIMIT_DATA covers anonymous
>          maps - so we should be getting good protection against OOM bugs. */
1926c1939
<         setrlimit(RLIMIT_DATA, &r); /* Ignore errors */
---
>       setrlimit(RLIMIT_DATA, &r); /* Ignore errors */
1931c1944
<       }
---
>     }
1933,1934c1946,1947
<       /* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered
<          before the dump is complete. */
---
>     /* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered
>        before the dump is complete. */
1936c1949
<       r.rlim_max = r.rlim_cur = 0;
---
>     r.rlim_max = r.rlim_cur = 0;
1938,1941c1951
<       setrlimit(RLIMIT_CORE, &r); /* Ignore errors */
< 
<       /* Isolate the process and configure standard descriptors. If out_file is
<          specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */
---
>     setrlimit(RLIMIT_CORE, &r); /* Ignore errors */
1943c1953,1954
<       setsid();
---
>     /* Isolate the process and configure standard descriptors. If out_file is
>        specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */
1945,1950c1956
<       dup2(dev_null_fd, 1);
<       
<       if(!is_qemu_log)
<         dup2(dev_null_fd, 2);
<       else
<         dup2(qemu_log_fds[i], 2);
---
>     setsid();
1952c1958,1959
<       if (out_file) {
---
>     dup2(dev_null_fd, 1);
>     dup2(dev_null_fd, 2);
1954c1961
<         dup2(dev_null_fd, 0);
---
>     if (out_file) {
1956c1963
<       } else {
---
>       dup2(dev_null_fd, 0);
1958,1965c1965
<         dup2(out_fd, 0);
<         close(out_fd);
< 
<       }
< 
<       close(dev_null_fd);
< 
<       /* Set up control and status pipes, close the unneeded original fds. */
---
>     } else {
1967,1968c1967,1968
<       if (dup2(ctl_pipe[0], FORKSRV_FD ) < 0) PFATAL("dup2() failed");
<       if (dup2(st_pipe[1], FORKSRV_FD + 1) < 0) PFATAL("dup2() failed");
---
>       dup2(out_fd, 0);
>       close(out_fd);
1970,1973c1970
<       close(ctl_pipe[0]);
<       close(ctl_pipe[1]);
<       close(st_pipe[0]);
<       close(st_pipe[1]);
---
>     }
1975,1976c1972
<       /* This should improve performance a bit, since it stops the linker from
<          doing extra work post-fork(). */
---
>     /* Set up control and status pipes, close the unneeded original fds. */
1978c1974,1975
<       setenv("LD_BIND_NOW", "1", 0);
---
>     if (dup2(ctl_pipe[0], FORKSRV_FD) < 0) PFATAL("dup2() failed");
>     if (dup2(st_pipe[1], FORKSRV_FD + 1) < 0) PFATAL("dup2() failed");
1980c1977,1980
<       /* Set sane defaults for ASAN if nothing else specified. */
---
>     close(ctl_pipe[0]);
>     close(ctl_pipe[1]);
>     close(st_pipe[0]);
>     close(st_pipe[1]);
1982,1984c1982,1985
<       setenv("ASAN_OPTIONS", "abort_on_error=1:"
<                              "detect_leaks=0:"
<                              "allocator_may_return_null=1", 0);
---
>     close(out_dir_fd);
>     close(dev_null_fd);
>     close(dev_urandom_fd);
>     close(fileno(plot_file));
1986,1987c1987,1988
<       /* MSAN is tricky, because it doesn't support abort_on_error=1 at this
<          point. So, we do this in a very hacky way. */
---
>     /* This should improve performance a bit, since it stops the linker from
>        doing extra work post-fork(). */
1989,1990c1990
<       setenv("MSAN_OPTIONS", "exit_code=" STRINGIFY(MSAN_ERROR) ":"
<                              "msan_track_origins=0", 0);
---
>     if (!getenv("LD_BIND_LAZY")) setenv("LD_BIND_NOW", "1", 0);
1992c1992
<       execv(target_path, argv + i * 4);
---
>     /* Set sane defaults for ASAN if nothing else specified. */
1994,1995c1994,1996
<       /* Use a distinctive bitmap signature to tell the parent about execv()
<          falling through. */
---
>     setenv("ASAN_OPTIONS", "abort_on_error=1:"
>                            "detect_leaks=0:"
>                            "allocator_may_return_null=1", 0);
1997,1998c1998,1999
<       *(u32*)(trace_bits[i]) = EXEC_FAIL_SIG;
<       exit(0);
---
>     /* MSAN is tricky, because it doesn't support abort_on_error=1 at this
>        point. So, we do this in a very hacky way. */
2000c2001,2002
<     }
---
>     setenv("MSAN_OPTIONS", "exit_code=" STRINGIFY(MSAN_ERROR) ":"
>                            "msan_track_origins=0", 0);
2002c2004
<     /* Close the unneeded endpoints. */
---
>     execv(target_path, argv);
2004,2005c2006,2007
<     close(ctl_pipe[0]);
<     close(st_pipe[1]);
---
>     /* Use a distinctive bitmap signature to tell the parent about execv()
>        falling through. */
2007,2008c2009,2010
<     fsrv_ctl_fd[i] = ctl_pipe[1];
<     fsrv_st_fd[i]  = st_pipe[0];
---
>     *(u32*)trace_bits = EXEC_FAIL_SIG;
>     exit(0);
2009a2012
>   }
2011,2015c2014
<     if(write(fsrv_ctl_fd[i], &i, 4) != 4)
<     {
<       if (stop_soon) return ;
<       FATAL("Unable to send cb_id to the new fork server of CB %02i (OOM?)", i);
<     }
---
>   /* Close the unneeded endpoints. */
2017,2021c2016,2017
<     if(write(fsrv_ctl_fd[i], shm_id + i, 4) != 4)
<     {
<       if (stop_soon) return ;
<       FATAL("Unable to send shm_id to the new fork server of CB %02i (OOM?)", i);
<     }
---
>   close(ctl_pipe[0]);
>   close(st_pipe[1]);
2022a2019,2020
>   fsrv_ctl_fd = ctl_pipe[1];
>   fsrv_st_fd  = st_pipe[0];
2024c2022
<     /* Wait for the fork server to come up, but don't wait too long. */
---
>   /* Wait for the fork server to come up, but don't wait too long. */
2026,2027c2024,2025
<     it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / 1000);
<     it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % 1000) * 1000;
---
>   it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / 1000);
>   it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % 1000) * 1000;
2029c2027
<     setitimer(ITIMER_REAL, &it, NULL);
---
>   setitimer(ITIMER_REAL, &it, NULL);
2031c2029
<     rlen = read(fsrv_st_fd[i], &status, 4);
---
>   rlen = read(fsrv_st_fd, &status, 4);
2033,2034c2031,2032
<     it.it_value.tv_sec = 0;
<     it.it_value.tv_usec = 0;
---
>   it.it_value.tv_sec = 0;
>   it.it_value.tv_usec = 0;
2036c2034
<     setitimer(ITIMER_REAL, &it, NULL);
---
>   setitimer(ITIMER_REAL, &it, NULL);
2038,2039c2036,2037
<     /* If we have a four-byte "hello" message from the server, we're all set.
<        Otherwise, try to figure out what went wrong. */
---
>   /* If we have a four-byte "hello" message from the server, we're all set.
>      Otherwise, try to figure out what went wrong. */
2041,2045c2039,2042
<     if (rlen == 4) {
<       OKF("All right - fork server is up for cb_%02i.", i);
<       // return;
<       continue;
<     }
---
>   if (rlen == 4) {
>     OKF("All right - fork server is up.");
>     return;
>   }
2047,2048c2044,2045
<     if (child_timed_out)
<       FATAL("Timeout while initializing fork server (adjusting -t may help)");
---
>   if (child_timed_out)
>     FATAL("Timeout while initializing fork server (adjusting -t may help)");
2050,2051c2047,2048
<     if (waitpid(forksrv_pid[i], &status, WUNTRACED) <= 0)
<       PFATAL("waitpid() failed");
---
>   if (waitpid(forksrv_pid, &status, 0) <= 0)
>     PFATAL("waitpid() failed");
2053c2050
<     if (WIFSIGNALED(status)) {
---
>   if (WIFSIGNALED(status)) {
2055c2052
<       if (mem_limit && mem_limit < 500 && uses_asan) {
---
>     if (mem_limit && mem_limit < 500 && uses_asan) {
2057,2061c2054,2058
<         SAYF("\n" cLRD "[-] " cRST
<              "Whoops, the target binary crashed suddenly, before receiving any input\n"
<              "    from the fuzzer! Since it seems to be built with ASAN and you have a\n"
<              "    restrictive memory limit configured, this is expected; please read\n"
<              "    %s/notes_for_asan.txt for help.\n", doc_path);
---
>       SAYF("\n" cLRD "[-] " cRST
>            "Whoops, the target binary crashed suddenly, before receiving any input\n"
>            "    from the fuzzer! Since it seems to be built with ASAN and you have a\n"
>            "    restrictive memory limit configured, this is expected; please read\n"
>            "    %s/notes_for_asan.txt for help.\n", doc_path);
2063c2060
<       } else if (!mem_limit) {
---
>     } else if (!mem_limit) {
2065,2067c2062,2064
<         SAYF("\n" cLRD "[-] " cRST
<              "Whoops, the target binary crashed suddenly, before receiving any input\n"
<              "    from the fuzzer! There are several probable explanations:\n\n"
---
>       SAYF("\n" cLRD "[-] " cRST
>            "Whoops, the target binary crashed suddenly, before receiving any input\n"
>            "    from the fuzzer! There are several probable explanations:\n\n"
2069,2070c2066,2067
<              "    - The binary is just buggy and explodes entirely on its own. If so, you\n"
<              "      need to fix the underlying problem or find a better replacement.\n\n"
---
>            "    - The binary is just buggy and explodes entirely on its own. If so, you\n"
>            "      need to fix the underlying problem or find a better replacement.\n\n"
2074,2076c2071,2073
<              "    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"
<              "      break afl-fuzz performance optimizations when running platform-specific\n"
<              "      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"
---
>            "    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"
>            "      break afl-fuzz performance optimizations when running platform-specific\n"
>            "      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"
2080,2081c2077,2078
<              "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
<              "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n");
---
>            "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
>            "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n");
2083c2080,2084
<       } else {
---
>     } else {
> 
>       SAYF("\n" cLRD "[-] " cRST
>            "Whoops, the target binary crashed suddenly, before receiving any input\n"
>            "    from the fuzzer! There are several probable explanations:\n\n"
2085,2092c2086,2089
<         SAYF("\n" cLRD "[-] " cRST
<              "Whoops, the target binary crashed suddenly, before receiving any input\n"
<              "    from the fuzzer! There are several probable explanations:\n\n"
< 
<              "    - The current memory limit (%s) is too restrictive, causing the\n"
<              "      target to hit an OOM condition in the dynamic linker. Try bumping up\n"
<              "      the limit with the -m setting in the command line. A simple way confirm\n"
<              "      this diagnosis would be:\n\n"
---
>            "    - The current memory limit (%s) is too restrictive, causing the\n"
>            "      target to hit an OOM condition in the dynamic linker. Try bumping up\n"
>            "      the limit with the -m setting in the command line. A simple way confirm\n"
>            "      this diagnosis would be:\n\n"
2095c2092
<             "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>            "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
2097c2094
<             "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>            "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
2100,2101c2097,2098
<              "      Tip: you can use ppvm (http://jwilk.net/software/ppvm) to quickly\n"
<              "      estimate the required amount of virtual memory for the binary.\n\n"
---
>            "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
>            "      estimate the required amount of virtual memory for the binary.\n\n"
2103,2104c2100,2101
<              "    - The binary is just buggy and explodes entirely on its own. If so, you\n"
<              "      need to fix the underlying problem or find a better replacement.\n\n"
---
>            "    - The binary is just buggy and explodes entirely on its own. If so, you\n"
>            "      need to fix the underlying problem or find a better replacement.\n\n"
2108,2110c2105,2107
<              "    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"
<              "      break afl-fuzz performance optimizations when running platform-specific\n"
<              "      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"
---
>            "    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"
>            "      break afl-fuzz performance optimizations when running platform-specific\n"
>            "      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"
2114,2120c2111,2113
<              "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
<              "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
<              DMS(mem_limit << 20), mem_limit - 1);
< 
<       }
< 
<       FATAL("Fork server crashed with signal %d", WTERMSIG(status));
---
>            "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
>            "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
>            DMS(mem_limit << 20), mem_limit - 1);
2124,2125c2117
<     if (*(u32*)(trace_bits[i]) == EXEC_FAIL_SIG)
<       FATAL("Unable to execute target application ('%s')", argv[0]);
---
>     FATAL("Fork server crashed with signal %d", WTERMSIG(status));
2127c2119
<     if (mem_limit && mem_limit < 500 && uses_asan) {
---
>   }
2129,2133c2121,2122
<       SAYF("\n" cLRD "[-] " cRST
<              "Hmm, looks like the target binary terminated before we could complete a\n"
<              "    handshake with the injected code. Since it seems to be built with ASAN and\n"
<              "    you have a restrictive memory limit configured, this is expected; please\n"
<              "    read %s/notes_for_asan.txt for help.\n", doc_path);
---
>   if (*(u32*)trace_bits == EXEC_FAIL_SIG)
>     FATAL("Unable to execute target application ('%s')", argv[0]);
2135c2124
<     } else if (!mem_limit) {
---
>   if (mem_limit && mem_limit < 500 && uses_asan) {
2137c2126
<       SAYF("\n" cLRD "[-] " cRST
---
>     SAYF("\n" cLRD "[-] " cRST
2139,2140c2128,2130
<            "    handshake with the injected code. Perhaps there is a horrible bug in the\n"
<            "    fuzzer. Poke <lcamtuf@coredump.cx> for troubleshooting tips.\n");
---
>            "    handshake with the injected code. Since it seems to be built with ASAN and\n"
>            "    you have a restrictive memory limit configured, this is expected; please\n"
>            "    read %s/notes_for_asan.txt for help.\n", doc_path);
2142c2132
<     } else {
---
>   } else if (!mem_limit) {
2144,2146c2134,2139
<       SAYF("\n" cLRD "[-] " cRST
<            "Hmm, looks like the target binary terminated before we could complete a\n"
<            "    handshake with the injected code. There are two probable explanations:\n\n"
---
>     SAYF("\n" cLRD "[-] " cRST
>          "Hmm, looks like the target binary terminated before we could complete a\n"
>          "    handshake with the injected code. Perhaps there is a horrible bug in the\n"
>          "    fuzzer. Poke <lcamtuf@coredump.cx> for troubleshooting tips.\n");
> 
>   } else {
2148,2150c2141,2148
<            "    - The current memory limit (%s) is too restrictive, causing an OOM\n"
<            "      fault in the dynamic linker. This can be fixed with the -m option. A\n"
<            "      simple way to confirm the diagnosis may be:\n\n"
---
>     SAYF("\n" cLRD "[-] " cRST
>          "Hmm, looks like the target binary terminated before we could complete a\n"
>          "    handshake with the injected code. There are %s probable explanations:\n\n"
> 
>          "%s"
>          "    - The current memory limit (%s) is too restrictive, causing an OOM\n"
>          "      fault in the dynamic linker. This can be fixed with the -m option. A\n"
>          "      simple way to confirm the diagnosis may be:\n\n"
2153c2151
<           "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>          "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
2155c2153
<           "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
---
>          "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
2158,2159c2156,2157
<           "      Tip: you can use ppvm (http://jwilk.net/software/ppvm) to quickly\n"
<           "      estimate the required amount of virtual memory for the binary.\n\n"
---
>          "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
>          "      estimate the required amount of virtual memory for the binary.\n\n"
2161,2163c2159,2165
<           "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
<           "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
<           DMS(mem_limit << 20), mem_limit - 1);
---
>          "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
>          "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
>          getenv(DEFER_ENV_VAR) ? "three" : "two",
>          getenv(DEFER_ENV_VAR) ?
>          "    - You are using deferred forkserver, but __AFL_INIT() is never\n"
>          "      reached before the program terminates.\n\n" : "",
>          DMS(mem_limit << 20), mem_limit - 1);
2165c2167
<     }
---
>   }
2167c2169
<     FATAL("Fork server handshake failed for CB %02i", i);
---
>   FATAL("Fork server handshake failed");
2169,2171d2170
<   }
<   OKF("init_forkserver() completes for %i cbs", num_of_cbs);
<   // exit(0);
2180d2178
<   int i;
2182c2180,2182
<   int* status = ck_alloc(sizeof(int) * num_of_cbs);
---
>   static u32 prev_timed_out = 0;
> 
>   int status = 0;
2185,2188c2185
<   for(i=0; i<num_of_cbs; i++)
<   {
<     status[i] = 0;
<     child_timed_out = 0;
---
>   child_timed_out = 0;
2190,2192c2187,2189
<     /* After this memset, trace_bits[] are effectively volatile, so we
<        must prevent any earlier operations from venturing into that
<        territory. */
---
>   /* After this memset, trace_bits[] are effectively volatile, so we
>      must prevent any earlier operations from venturing into that
>      territory. */
2194,2195c2191,2192
<     memset(trace_bits[i], 0, MAP_SIZE);
<     MEM_BARRIER();
---
>   memset(trace_bits, 0, MAP_SIZE);
>   MEM_BARRIER();
2197,2200c2194,2197
<     /* If we're running in "dumb" mode, we can't rely on the fork server
<        logic compiled into the target program, so we will just keep calling
<        execve(). There is a bit of code duplication between here and 
<        init_forkserver(), but c'est la vie. */
---
>   /* If we're running in "dumb" mode, we can't rely on the fork server
>      logic compiled into the target program, so we will just keep calling
>      execve(). There is a bit of code duplication between here and 
>      init_forkserver(), but c'est la vie. */
2202c2199
<     if (dumb_mode == 1 || no_forkserver) {
---
>   if (dumb_mode == 1 || no_forkserver) {
2204c2201
<       child_pid[i] = fork();
---
>     child_pid = fork();
2206c2203
<       if (child_pid[i] < 0) PFATAL("fork() failed");
---
>     if (child_pid < 0) PFATAL("fork() failed");
2208c2205
<       if (!child_pid[i]) {
---
>     if (!child_pid) {
2210c2207
<         struct rlimit r;
---
>       struct rlimit r;
2212c2209
<         if (mem_limit) {
---
>       if (mem_limit) {
2214c2211
<           r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;
---
>         r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;
2218c2215
<           setrlimit(RLIMIT_AS, &r); /* Ignore errors */
---
>         setrlimit(RLIMIT_AS, &r); /* Ignore errors */
2222c2219
<           setrlimit(RLIMIT_DATA, &r); /* Ignore errors */
---
>         setrlimit(RLIMIT_DATA, &r); /* Ignore errors */
2226,2228c2223
<         }
< 
<         r.rlim_max = r.rlim_cur = 0;
---
>       }
2230c2225
<         setrlimit(RLIMIT_CORE, &r); /* Ignore errors */
---
>       r.rlim_max = r.rlim_cur = 0;
2232,2233c2227
<         /* Isolate the process and configure standard descriptors. If out_file is
<            specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */
---
>       setrlimit(RLIMIT_CORE, &r); /* Ignore errors */
2235c2229,2230
<         setsid();
---
>       /* Isolate the process and configure standard descriptors. If out_file is
>          specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */
2237,2238c2232
<         dup2(dev_null_fd, 1);
<         dup2(dev_null_fd, 2);
---
>       setsid();
2240c2234,2235
<         if (out_file) {
---
>       dup2(dev_null_fd, 1);
>       dup2(dev_null_fd, 2);
2242c2237
<           dup2(dev_null_fd, 0);
---
>       if (out_file) {
2244c2239
<         } else {
---
>         dup2(dev_null_fd, 0);
2246,2247c2241
<           dup2(out_fd, 0);
<           close(out_fd);
---
>       } else {
2249c2243,2244
<         }
---
>         dup2(out_fd, 0);
>         close(out_fd);
2251c2246
<         close(dev_null_fd);
---
>       }
2253c2248
<         /* Set sane defaults for ASAN if nothing else specified. */
---
>       /* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */
2255,2257c2250,2253
<         setenv("ASAN_OPTIONS", "abort_on_error=1:"
<                                "detect_leaks=0:"
<                                "allocator_may_return_null=1", 0);
---
>       close(dev_null_fd);
>       close(out_dir_fd);
>       close(dev_urandom_fd);
>       close(fileno(plot_file));
2259,2260c2255
<         setenv("MSAN_OPTIONS", "exit_code=" STRINGIFY(MSAN_ERROR) ":"
<                                "msan_track_origins=0", 0);
---
>       /* Set sane defaults for ASAN if nothing else specified. */
2262c2257,2259
<         execv(target_path, argv + i * 4);
---
>       setenv("ASAN_OPTIONS", "abort_on_error=1:"
>                              "detect_leaks=0:"
>                              "allocator_may_return_null=1", 0);
2264,2265c2261,2262
<         /* Use a distinctive bitmap value to tell the parent about execv()
<            falling through. */
---
>       setenv("MSAN_OPTIONS", "exit_code=" STRINGIFY(MSAN_ERROR) ":"
>                              "msan_track_origins=0", 0);
2267,2268c2264
<         *(u32*)(trace_bits[i]) = EXEC_FAIL_SIG;
<         exit(0);
---
>       execv(target_path, argv);
2270c2266,2267
<       }
---
>       /* Use a distinctive bitmap value to tell the parent about execv()
>          falling through. */
2272c2269,2270
<     } else {
---
>       *(u32*)trace_bits = EXEC_FAIL_SIG;
>       exit(0);
2274c2272
<       s32 res;
---
>     }
2276,2277c2274
<       /* In non-dumb mode, we have the fork server up and running, so simply
<          tell it to have at it, and then read back PID. */
---
>   } else {
2279c2276
<       if ((res = write(fsrv_ctl_fd[i], status + i, 4)) != 4) {
---
>     s32 res;
2281,2282c2278,2279
<         if (stop_soon) return 0;
<         RPFATAL(res, "Unable to request new process from fork server (OOM?)");
---
>     /* In non-dumb mode, we have the fork server up and running, so simply
>        tell it to have at it, and then read back PID. */
2284c2281
<       }
---
>     if ((res = write(fsrv_ctl_fd, &prev_timed_out, 4)) != 4) {
2286,2287c2283,2284
<       // if ((res = read(fsrv_st_fd[i], &child_pid, 4)) != 4) {
<       if ((res = read(fsrv_st_fd[i], child_pid + i, 4)) != 4) {
---
>       if (stop_soon) return 0;
>       RPFATAL(res, "Unable to request new process from fork server (OOM?)");
2289,2290c2286
<         if (stop_soon) return 0;
<         RPFATAL(res, "Unable to request new process from fork server (OOM?)");
---
>     }
2292c2288
<       }
---
>     if ((res = read(fsrv_st_fd, &child_pid, 4)) != 4) {
2294c2290,2291
<       if (child_pid[i] <= 0) FATAL("Fork server is misbehaving (OOM?)");
---
>       if (stop_soon) return 0;
>       RPFATAL(res, "Unable to request new process from fork server (OOM?)");
2296a2294,2296
> 
>     if (child_pid <= 0) FATAL("Fork server is misbehaving (OOM?)");
> 
2298,2304d2297
<   // for(i=0; i<num_of_cbs; i++)
<   //   ACTF("child_pid_%d: %d", i, child_pid[i]);
<   // while(1);
<   for(i=0; i<num_of_cbs; i++)
<   {
<     status[i] = 0;
<     /* Configure timeout, as requested by user, then wait for child to terminate. */
2306,2307c2299
<     it.it_value.tv_sec = (exec_tmout / 1000);
<     it.it_value.tv_usec = (exec_tmout % 1000) * 1000;
---
>   /* Configure timeout, as requested by user, then wait for child to terminate. */
2309c2301,2302
<     setitimer(ITIMER_REAL, &it, NULL);
---
>   it.it_value.tv_sec = (exec_tmout / 1000);
>   it.it_value.tv_usec = (exec_tmout % 1000) * 1000;
2311c2304
<     /* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */
---
>   setitimer(ITIMER_REAL, &it, NULL);
2313c2306
<     if (dumb_mode == 1 || no_forkserver) {
---
>   /* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */
2315c2308
<       if (waitpid(child_pid[i], status + i, WUNTRACED) <= 0) PFATAL("waitpid() failed");
---
>   if (dumb_mode == 1 || no_forkserver) {
2317c2310
<     } else {
---
>     if (waitpid(child_pid, &status, 0) <= 0) PFATAL("waitpid() failed");
2319c2312
<       s32 res;
---
>   } else {
2321c2314
<       if ((res = read(fsrv_st_fd[i], status + i, 4)) != 4) {
---
>     s32 res;
2323,2324c2316
<         if (stop_soon) return 0;
<         RPFATAL(res, "Unable to communicate with fork server");
---
>     if ((res = read(fsrv_st_fd, &status, 4)) != 4) {
2326c2318,2319
<       }
---
>       if (stop_soon) return 0;
>       RPFATAL(res, "Unable to communicate with fork server");
2329,2334d2321
<     // ACTF("status[%d]: %d", i, status[i]);
<     child_pid[i] = 0;
<     it.it_value.tv_sec = 0;
<     it.it_value.tv_usec = 0;
< 
<     setitimer(ITIMER_REAL, &it, NULL);
2336d2322
<     total_execs++;
2339,2341c2325,2335
<     /* Any subsequent operations on trace_bits must not be moved by the
<        compiler above this point. Past this location, trace_bits[] behave
<        very normally and do not have to be treated as volatile. */
---
>   child_pid = 0;
>   it.it_value.tv_sec = 0;
>   it.it_value.tv_usec = 0;
> 
>   setitimer(ITIMER_REAL, &it, NULL);
> 
>   total_execs++;
> 
>   /* Any subsequent operations on trace_bits must not be moved by the
>      compiler below this point. Past this location, trace_bits[] behave
>      very normally and do not have to be treated as volatile. */
2345,2352c2339
<   for(i=0; i<num_of_cbs; i++)
<   {
<     if(*(u32*)(trace_bits[i]) == EXEC_FAIL_SIG)
<     {
<       tb4 = EXEC_FAIL_SIG;
<       break;
<     }
<   }
---
>   tb4 = *(u32*)trace_bits;
2355c2342
<     classify_counts((u64**)trace_bits);
---
>   classify_counts((u64*)trace_bits);
2357c2344
<     classify_counts((u32**)trace_bits);
---
>   classify_counts((u32*)trace_bits);
2359c2346,2348
<   
---
> 
>   prev_timed_out = child_timed_out;
> 
2364,2370c2353,2356
<   for(i=0; i<num_of_cbs; i++)
<   {
<     if (WIFSIGNALED(status[i]) && !stop_soon) {
<       kill_signal = WTERMSIG(status[i]);
<       ck_free(status);
<       return FAULT_CRASH;
<     }
---
>   if (WIFSIGNALED(status) && !stop_soon) {
>     kill_signal = WTERMSIG(status);
>     return FAULT_CRASH;
>   }
2375,2385c2361,2363
<     if (uses_asan && WEXITSTATUS(status[i]) == MSAN_ERROR) {
<       kill_signal = 0;
<       ck_free(status);
<       return FAULT_CRASH;
<     }
< 
<     if ((dumb_mode == 1 || no_forkserver) && tb4 == EXEC_FAIL_SIG)
<     {
<       ck_free(status);
<       return FAULT_ERROR;
<     }
---
>   if (uses_asan && WEXITSTATUS(status) == MSAN_ERROR) {
>     kill_signal = 0;
>     return FAULT_CRASH;
2388c2366,2368
<   ck_free(status);
---
>   if ((dumb_mode == 1 || no_forkserver) && tb4 == EXEC_FAIL_SIG)
>     return FAULT_ERROR;
> 
2486c2466
<   if (!dumb_mode && !no_forkserver && !forksrv_pid)
---
>   if (dumb_mode != 1 && !no_forkserver && !forksrv_pid)
2488c2468
<   // while(1);
---
> 
2498c2478
<     // ACTF("run_target() 1 at staget_cur: %d", stage_cur);
---
> 
2500c2480
<     
---
> 
2511,2512c2491,2492
<     cksum = hash32_v(trace_bits, MAP_SIZE, num_of_cbs, HASH_CONST);
<     // ACTF("cksum: %u @%d", cksum, stage_cur);
---
>     cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
> 
2528c2508
<   
---
> 
2543a2524
> 
2549c2530
<   
---
> 
2569a2551
> 
2586,2590c2568
<   {
<     u32 j;
<     for(j=0; j<num_of_cbs; j++)
<       if (trace_bits[j][i]) return;
<   }
---
>     if (trace_bits[i]) return;
2603d2580
<   u32 id = 0;
2604a2582
>   u8* skip_crashes = getenv("AFL_SKIP_CRASHES");
2653c2631
<           if (timeout_given == 2) {
---
>           if (timeout_given > 1) {
2687a2666,2672
>         if (skip_crashes) {
>           WARNF("Test case results in a crash (skipping)");
>           q->cal_failed = CAL_CHANCES;
>           cal_failures++;
>           break;
>         }
> 
2709c2694
<                "      Tip: you can use ppvm (http://jwilk.net/software/ppvm) to quickly\n"
---
>                "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
2772d2756
<     id++;
2779,2780c2763,2764
<       FATAL("All test cases time out, giving up!");
<       // WARNF("All test cases timeout!");
---
>       FATAL("All test cases time out%s, giving up!",
>             skip_crashes ? " or crash" : "");
2782,2783c2766,2768
<     WARNF("Skipped %u test cases (%0.02f%%) due to timeouts.", cal_failures,
<           ((double)cal_failures) * 100 / queued_paths);
---
>     WARNF("Skipped %u test cases (%0.02f%%) due to timeouts%s.", cal_failures,
>           ((double)cal_failures) * 100 / queued_paths,
>           skip_crashes ? " or crashes" : "");
2855c2840
<         sscanf(rsl + 3, "%08u", &orig_id) == 1 && orig_id == id) {
---
>         sscanf(rsl + 3, "%06u", &orig_id) == 1 && orig_id == id) {
2868c2853
<       if (src_str && sscanf(src_str + 1, "%08u", &src_id) == 1) {
---
>       if (src_str && sscanf(src_str + 1, "%06u", &src_id) == 1) {
2888c2873
<       nfn = alloc_printf("%s/queue/id:%08u,orig:%s", out_dir, id, use_name);
---
>       nfn = alloc_printf("%s/queue/id:%06u,orig:%s", out_dir, id, use_name);
2892c2877
<       nfn = alloc_printf("%s/queue/id_%08u", out_dir, id);
---
>       nfn = alloc_printf("%s/queue/id_%06u", out_dir, id);
2929c2914
<     sprintf(ret, "sync:%s,src:%08u", syncing_party, syncing_case);
---
>     sprintf(ret, "sync:%s,src:%06u", syncing_party, syncing_case);
2933c2918
<     sprintf(ret, "src:%08u", current_entry);
---
>     sprintf(ret, "src:%06u", current_entry);
2936c2921
<       sprintf(ret + strlen(ret), "+%08u", splicing_with);
---
>       sprintf(ret + strlen(ret), "+%06u", splicing_with);
3023c3008
<   u32 key_cksum = hash32_v(trace_bits, MAP_SIZE, num_of_cbs, HASH_CONST);
---
>   u32 key_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
3039c3024
<     fn = alloc_printf("%s/queue/id:%08u,%s", out_dir, queued_paths,
---
>     fn = alloc_printf("%s/queue/id:%06u,%s", out_dir, queued_paths,
3044c3029
<     fn = alloc_printf("%s/queue/id_%08u", out_dir, queued_paths);
---
>     fn = alloc_printf("%s/queue/id_%06u", out_dir, queued_paths);
3055d3039
<     // queue_top->exec_cksum = hash32_v(trace_bits, MAP_SIZE, num_of_cbs, HASH_CONST);
3063d3046
< 
3097c3080
<         simplify_trace((u64**)trace_bits);
---
>         simplify_trace((u64*)trace_bits);
3099c3082
<         simplify_trace((u32**)trace_bits);
---
>         simplify_trace((u32*)trace_bits);
3108c3091
<       fn = alloc_printf("%s/hangs/id:%08llu,%s", out_dir,
---
>       fn = alloc_printf("%s/hangs/id:%06llu,%s", out_dir,
3113c3096
<       fn = alloc_printf("%s/hangs/id_%08llu", out_dir,
---
>       fn = alloc_printf("%s/hangs/id_%06llu", out_dir,
3136c3119
<         simplify_trace((u64**)trace_bits);
---
>         simplify_trace((u64*)trace_bits);
3138c3121
<         simplify_trace((u32**)trace_bits);
---
>         simplify_trace((u32*)trace_bits);
3149c3132
<       fn = alloc_printf("%s/crashes/id:%08llu,sig:%02u,%s", out_dir,
---
>       fn = alloc_printf("%s/crashes/id:%06llu,sig:%02u,%s", out_dir,
3154c3137
<       fn = alloc_printf("%s/crashes/id_%08llu_%02u", out_dir, unique_crashes,
---
>       fn = alloc_printf("%s/crashes/id_%06llu_%02u", out_dir, unique_crashes,
3159,3163d3141
<       if(unique_crashes == 0)
<       {
<         first_crash_time = get_cur_time();
<       }
< 
3202,3205d3179
<   // char cmd[128];
<   // sprintf(cmd, "ln -sf %s/fuzzer_stats /home/vagrant/fuzzer_stats", out_dir);
<   // system(cmd);
< 
3208,3210c3182,3183
<   // if (in_place_resume) fn = alloc_printf("%s/fuzzer_stats", out_dir);
<   // else fn = alloc_printf("%s/../fuzzer_stats", in_dir);
<   fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
---
>   if (in_place_resume) fn = alloc_printf("%s/fuzzer_stats", out_dir);
>   else fn = alloc_printf("%s/../fuzzer_stats", in_dir);
3229a3203,3239
> /* The same, but for timeouts. The idea is that when resuming sessions without
>    -t given, we don't want to keep auto-scaling the timeout over and over
>    again to prevent it from growing due to random flukes. */
> 
> static void find_timeout(void) {
> 
>   static u8 tmp[4096]; /* Ought to be enough for anybody. */
> 
>   u8  *fn, *off;
>   s32 fd, i;
>   u32 ret;
> 
>   if (!resuming_fuzz) return;
> 
>   if (in_place_resume) fn = alloc_printf("%s/fuzzer_stats", out_dir);
>   else fn = alloc_printf("%s/../fuzzer_stats", in_dir);
> 
>   fd = open(fn, O_RDONLY);
>   ck_free(fn);
> 
>   if (fd < 0) return;
> 
>   i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */
>   close(fd);
> 
>   off = strstr(tmp, "exec_timeout   : ");
>   if (!off) return;
> 
>   ret = atoi(off + 17);
>   if (ret <= 4) return;
> 
>   exec_tmout = ret;
>   timeout_given = 3;
> 
> }
> 
> 
3236,3237c3246
<   // u8* fn = alloc_printf("%s/fuzzer_stats", out_dir);
<   u8* fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
---
>   u8* fn = alloc_printf("%s/fuzzer_stats", out_dir);
3262,3292c3271,3295
<   fprintf(f, "start_time                  : %llu\n"
<              "last_update                 : %llu\n"
<              "fuzzer_pid                  : %u\n"
<              "first_crash_time            : %llu\n"
<              "last_crash_time             : %llu\n"
<              "cycles_done                 : %llu\n"
<              "execs_done                  : %llu\n"
<              "execs_per_sec               : %0.02f\n"
<              "paths_total                 : %u\n"
<              "paths_found                 : %u\n"
<              "paths_imported              : %u\n"
<              "max_depth                   : %u\n"
<              "cur_path                    : %u\n"
<              "pending_favs                : %u\n"
<              "pending_total               : %u\n"
<              "variable_paths              : %u\n"
<              "bitmap_cvg                  : %0.02f%%\n"
<              "unique_crashes              : %llu\n"
<              "unique_hangs                : %llu\n"
<              "imported_paths              : %u\n"
<              "checked_paths               : %i\n"
<              "imported_paths_fuz         : %i\n"
<              "checked_paths_fuz          : %i\n"
<              "imported_paths_s2e          : %i\n"
<              "checked_paths_s2e           : %i\n"
<              "imported_paths_traffic      : %i\n"
<              "checked_paths_traffic       : %i\n" 
<              "sync_times                  : %i\n"
<              "afl_banner                  : %s\n"
<              "afl_version                 : " VERSION "\n"
<              "command_line                : %s\n",
---
>   fprintf(f, "start_time     : %llu\n"
>              "last_update    : %llu\n"
>              "fuzzer_pid     : %u\n"
>              "cycles_done    : %llu\n"
>              "execs_done     : %llu\n"
>              "execs_per_sec  : %0.02f\n"
>              "paths_total    : %u\n"
>              "paths_favored  : %u\n"
>              "paths_found    : %u\n"
>              "paths_imported : %u\n"
>              "max_depth      : %u\n"
>              "cur_path       : %u\n"
>              "pending_favs   : %u\n"
>              "pending_total  : %u\n"
>              "variable_paths : %u\n"
>              "bitmap_cvg     : %0.02f%%\n"
>              "unique_crashes : %llu\n"
>              "unique_hangs   : %llu\n"
>              "last_path      : %llu\n"
>              "last_crash     : %llu\n"
>              "last_hang      : %llu\n"
>              "exec_timeout   : %u\n"
>              "afl_banner     : %s\n"
>              "afl_version    : " VERSION "\n"
>              "command_line   : %s\n",
3294d3296
<              first_crash_time / 1000, last_crash_time /1000,
3296,3297c3298,3299
<              queued_paths, queued_discovered, queued_imported, max_depth,
<              current_entry, pending_favored, pending_not_fuzzed,
---
>              queued_paths, queued_favored, queued_discovered, queued_imported,
>              max_depth, current_entry, pending_favored, pending_not_fuzzed,
3299,3304c3301,3303
<              queued_imported, sync_count, 
<              imported_paths[FUZ_SRC], checked_paths[FUZ_SRC],
<              imported_paths[S2E_SRC], checked_paths[S2E_SRC],
<              imported_paths[TRA_SRC], checked_paths[TRA_SRC],
<              sync_times,
<              use_banner, orig_cmdline); /* ignore errors */
---
>              last_path_time / 1000, last_crash_time / 1000,
>              last_hang_time / 1000, exec_tmout, use_banner, orig_cmdline);
>              /* ignore errors */
3480,3482c3479
<   // u8 *fn = alloc_printf("%s/fuzzer_stats", out_dir);
<   u8* fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
<   static s32 out_dir_fd;
---
>   u8 *fn = alloc_printf("%s/fuzzer_stats", out_dir);
3490a3488,3489
> #ifndef __sun
> 
3502a3502,3503
> #endif /* !__sun */
> 
3567d3567
<   // fn = alloc_printf("%s/.synced", local_out_dir);
3600c3600,3606
<   /* All right, let's do <out_dir>/crashes/id:* and <out_dir>/hangs/id:*. */
---
>   /* All right, let's do <out_dir>/crashes/id:* and <out_dir>/hangs/id:*. */
> 
>   if (!in_place_resume) {
> 
>     fn = alloc_printf("%s/crashes/README.txt", out_dir);
>     unlink(fn); /* Ignore errors */
>     ck_free(fn);
3602,3604c3608
<   fn = alloc_printf("%s/crashes/README.txt", out_dir);
<   unlink(fn); /* Ignore errors */
<   ck_free(fn);
---
>   }
3615a3620,3621
> #ifndef SIMPLE_FILES
> 
3619a3626,3633
> #else
> 
>     u8* nfn = alloc_printf("%s_%04u%02u%02u%02u%02u%02u", fn,
>                            t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
>                            t->tm_hour, t->tm_min, t->tm_sec);
> 
> #endif /* ^!SIMPLE_FILES */
> 
3636a3651,3652
> #ifndef SIMPLE_FILES
> 
3640a3657,3664
> #else
> 
>     u8* nfn = alloc_printf("%s_%04u%02u%02u%02u%02u%02u", fn,
>                            t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
>                            t->tm_hour, t->tm_min, t->tm_sec);
> 
> #endif /* ^!SIMPLE_FILES */
> 
3652d3675
<   // fn = alloc_printf("%s/.cur_input", local_out_dir);
3657d3679
<   // fn = alloc_printf("%s/fuzz_bitmap", local_out_dir);
3662,3663c3684
<     // fn  = alloc_printf("%s/fuzzer_stats", out_dir);
<     fn = alloc_printf("%s/fuzzer_stats", remote_out_dir);
---
>     fn  = alloc_printf("%s/fuzzer_stats", out_dir);
3669d3689
<   // fn = alloc_printf("%s/plot_data", local_out_dir);
3694a3715,3717
> static void check_term_size(void);
> 
> 
3774a3798,3802
>   /* Honor AFL_EXIT_WHEN_DONE. */
> 
>   if (!dumb_mode && cycles_wo_finds > 20 && !pending_not_fuzzed &&
>       getenv("AFL_EXIT_WHEN_DONE")) stop_soon = 1;
> 
3781c3809
<   t_bits = ((MAP_SIZE * num_of_cbs) << 3) - count_bits(virgin_bits);
---
>   t_bits = (MAP_SIZE << 3) - count_bits(virgin_bits);
3789a3818,3819
>     check_term_size();
> 
3793a3824,3832
>   if (term_too_small) {
> 
>     SAYF(cBRI "Your terminal is too small to display the UI.\n"
>          "Please resize terminal window to at least 80x25.\n" cNOR);
> 
>     return;
> 
>   }
> 
3893c3932
<   /* This gets funny becuse we want to print several variable-length variables
---
>   /* This gets funny because we want to print several variable-length variables
4000c4039
<             DI(stage_finds[STAGE_FLIP4]), DI(stage_cycles[STAGE_FLIP2]),
---
>             DI(stage_finds[STAGE_FLIP2]), DI(stage_cycles[STAGE_FLIP2]),
4041,4050d4079
<   u8 _tmp[256];
<   memset(_tmp, ' ', banner_pad);
<   if(sync_id)
<     sprintf(_tmp, "%s|%s[%s]", DI(queued_imported), DI(sync_count), DI(sync_times));
<   else
<     sprintf(_tmp, "%s", (u8*)"n/a");
< 
<   // SAYF(bV bSTOP "  dictionary : " cNOR "%-37s " bSTG bV bSTOP
<   //      "  imported : " cNOR "%-10s " bSTG bV "\n", tmp,
<   //      sync_id ? DI(queued_imported) : (u8*)"n/a");
4052,4053c4081,4083
<        "  imported : " cNOR "%-10s " bSTG bV "\n", tmp, _tmp);
<   
---
>        "  imported : " cNOR "%-10s " bSTG bV "\n", tmp,
>        sync_id ? DI(queued_imported) : (u8*)"n/a");
> 
4216a4247,4250
>   } else if (timeout_given == 3) {
> 
>     ACTF("Applying timeout settings from resumed session (%u ms).", exec_tmout);
> 
4242,4253c4276
<   // static u8 clean_trace[MAP_SIZE];
<   static u8** clean_trace = NULL;
<   int cb_id;
<   if(!clean_trace)
<   {
<     clean_trace = ck_alloc(sizeof(u8*) * num_of_cbs);
<     for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<     {
<       clean_trace[cb_id] = ck_alloc(sizeof(u8) * MAP_SIZE);
<     }
<   }
< 
---
>   static u8 clean_trace[MAP_SIZE];
4293c4316
<       // ACTF("run_target() 2");
---
> 
4301c4324
<       cksum = hash32_v(trace_bits, MAP_SIZE, num_of_cbs, HASH_CONST);
---
>       cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
4324,4325c4347
<           for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<             memcpy(clean_trace[cb_id], trace_bits[cb_id], MAP_SIZE);
---
>           memcpy(clean_trace, trace_bits, MAP_SIZE);
4357,4358c4379,4380
<     for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<       memcpy(trace_bits[cb_id], clean_trace[cb_id], MAP_SIZE);
---
> 
>     memcpy(trace_bits, clean_trace, MAP_SIZE);
4380a4403,4409
>   if (post_handler) {
> 
>     out_buf = post_handler(out_buf, &len);
>     if (!out_buf || !len) return 0;
> 
>   }
> 
4382c4411
<   // ACTF("run_target() 3");
---
> 
4476c4505
<      coverage translates to better targets. Multipler from 0.25x to 3x. */
---
>      coverage translates to better targets. Multiplier from 0.25x to 3x. */
4523a4553,4738
> /* Helper function to see if a particular change (xor_val = old ^ new) could
>    be a product of deterministic bit flips with the lengths and stepovers
>    attempted by afl-fuzz. This is used to avoid dupes in some of the
>    deterministic fuzzing operations that follow bit flips. We also
>    return 1 if xor_val is zero, which implies that the old and attempted new
>    values are identical and the exec would be a waste of time. */
> 
> static u8 could_be_bitflip(u32 xor_val) {
> 
>   u32 sh = 0;
> 
>   if (!xor_val) return 1;
> 
>   /* Shift left until first bit set. */
> 
>   while (!(xor_val & 1)) { sh++; xor_val >>= 1; }
> 
>   /* 1-, 2-, and 4-bit patterns are OK anywhere. */
> 
>   if (xor_val == 1 || xor_val == 3 || xor_val == 15) return 1;
> 
>   /* 8-, 16-, and 32-bit patterns are OK only if shift factor is
>      divisible by 8, since that's the stepover for these ops. */
> 
>   if (sh & 7) return 0;
> 
>   if (xor_val == 0xff || xor_val == 0xffff || xor_val == 0xffffffff)
>     return 1;
> 
>   return 0;
> 
> }
> 
> 
> /* Helper function to see if a particular value is reachable through
>    arithmetic operations. Used for similar purposes. */
> 
> static u8 could_be_arith(u32 old_val, u32 new_val, u8 blen) {
> 
>   u32 i, ov = 0, nv = 0, diffs = 0;
> 
>   if (old_val == new_val) return 1;
> 
>   /* See if one-byte adjustments to any byte could produce this result. */
> 
>   for (i = 0; i < blen; i++) {
> 
>     u8 a = old_val >> (8 * i),
>        b = new_val >> (8 * i);
> 
>     if (a != b) { diffs++; ov = a; nv = b; }
> 
>   }
> 
>   /* If only one byte differs and the values are within range, return 1. */
> 
>   if (diffs == 1) {
> 
>     if ((u8)(ov - nv) <= ARITH_MAX ||
>         (u8)(nv - ov) <= ARITH_MAX) return 1;
> 
>   }
> 
>   if (blen == 1) return 0;
> 
>   /* See if two-byte adjustments to any byte would produce this result. */
> 
>   diffs = 0;
> 
>   for (i = 0; i < blen / 2; i++) {
> 
>     u16 a = old_val >> (16 * i),
>         b = new_val >> (16 * i);
> 
>     if (a != b) { diffs++; ov = a; nv = b; }
> 
>   }
> 
>   /* If only one word differs and the values are within range, return 1. */
> 
>   if (diffs == 1) {
> 
>     if ((u16)(ov - nv) <= ARITH_MAX ||
>         (u16)(nv - ov) <= ARITH_MAX) return 1;
> 
>     ov = SWAP16(ov); nv = SWAP16(nv);
> 
>     if ((u16)(ov - nv) <= ARITH_MAX ||
>         (u16)(nv - ov) <= ARITH_MAX) return 1;
> 
>   }
> 
>   /* Finally, let's do the same thing for dwords. */
> 
>   if (blen == 4) {
> 
>     if ((u32)(old_val - new_val) <= ARITH_MAX ||
>         (u32)(new_val - old_val) <= ARITH_MAX) return 1;
> 
>     new_val = SWAP32(new_val);
>     old_val = SWAP32(old_val);
> 
>     if ((u32)(old_val - new_val) <= ARITH_MAX ||
>         (u32)(new_val - old_val) <= ARITH_MAX) return 1;
> 
>   }
> 
>   return 0;
> 
> }
> 
> 
> /* Last but not least, a similar helper to see if insertion of an 
>    interesting integer is redundant given the insertions done for
>    shorter blen. The last param (check_le) is set if the caller
>    already executed LE insertion for current blen and wants to see
>    if BE variant passed in new_val is unique. */
> 
> static u8 could_be_interest(u32 old_val, u32 new_val, u8 blen, u8 check_le) {
> 
>   u32 i, j;
> 
>   if (old_val == new_val) return 1;
> 
>   /* See if one-byte insertions from interesting_8 over old_val could
>      produce new_val. */
> 
>   for (i = 0; i < blen; i++) {
> 
>     for (j = 0; j < sizeof(interesting_8); j++) {
> 
>       u32 tval = (old_val & ~(0xff << (i * 8))) |
>                  (((u8)interesting_8[j]) << (i * 8));
> 
>       if (new_val == tval) return 1;
> 
>     }
> 
>   }
> 
>   /* Bail out unless we're also asked to examine two-byte LE insertions
>      as a preparation for BE attempts. */
> 
>   if (blen == 2 && !check_le) return 0;
> 
>   /* See if two-byte insertions over old_val could give us new_val. */
> 
>   for (i = 0; i < blen - 1; i++) {
> 
>     for (j = 0; j < sizeof(interesting_16) / 2; j++) {
> 
>       u32 tval = (old_val & ~(0xffff << (i * 8))) |
>                  (((u16)interesting_16[j]) << (i * 8));
> 
>       if (new_val == tval) return 1;
> 
>       /* Continue here only if blen > 2. */
> 
>       if (blen > 2) {
> 
>         tval = (old_val & ~(0xffff << (i * 8))) |
>                (SWAP16(interesting_16[j]) << (i * 8));
> 
>         if (new_val == tval) return 1;
> 
>       }
> 
>     }
> 
>   }
> 
>   if (blen == 4 && check_le) {
> 
>     /* See if four-byte insertions could produce the same result
>        (LE only). */
> 
>     for (j = 0; j < sizeof(interesting_32) / 4; j++)
>       if (new_val == (u32)interesting_32[j]) return 1;
> 
>   }
> 
>   return 0;
> 
> }
> 
> 
4525c4740
<    function is a tad too long... returns 0 if fuzzed successfuly, 1 if
---
>    function is a tad too long... returns 0 if fuzzed successfully, 1 if
4722c4937
<     if ((stage_cur & 7) == 7) {
---
>     if (!dumb_mode && (stage_cur & 7) == 7) {
4724c4939
<       u32 cksum = hash32_v(trace_bits, MAP_SIZE, num_of_cbs, HASH_CONST);
---
>       u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
4882c5097
<         cksum = hash32_v(trace_bits, MAP_SIZE, num_of_cbs, HASH_CONST);
---
>         cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
4936c5151
<     if (!*(u16*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
4972c5187,5188
<     if (!*(u32*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
>         !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
5027,5042c5243,5246
<       /* Don't bother with arithmetics that produce results equivalent
<          to previously-attempted bitflips. To evaluate this, we look at
<          XOR of the values before and after the arithmetic operation, and
<          compare them to XOR results that can be produced by bitflips.
< 
<          Single bitflips can yield 1, 2, 4, 8, 16, 32, 64, 128,
<          Two-in-a-row can yield 1*, 3, 6, 12, 24, 48, 96, 128*, 192,
<          Four in a row: 1*, 3*, 7, 15, 30, 60, 120, 128*, 192*, 224, 240,
<          Full-byte flip (with a 1-byte stepover) takes care of 255.
< 
<        */
< 
<       if (r > 4 && r != 8  && r != 16 && r != 32 && r != 64 && r != 128 &&
<           r != 6 && r != 12 && r != 24 && r != 48 && r != 96 && r != 192 &&
<           r != 7 && r != 15 && r != 30 && r != 60 && r != 120 && r != 224 &&
<           r != 240 && r != 255) {
---
>       /* Do arithmetic operations only if the result couldn't be a product
>          of a bitflip. */
> 
>       if (!could_be_bitflip(r)) {
5052c5256
<       r = orig ^ (orig - j);
---
>       r =  orig ^ (orig - j);
5054,5056c5258
<       if (r > 4 && r != 8 && r != 16 && r != 32 && r != 64 && r != 128 &&
<           r != 6 && r != 12 && r != 24 && r != 48 && r != 96 && r != 192 &&
<           r != 15 && r != 30 && r != 60 && r != 120 && r != 240 && r != 255) {
---
>       if (!could_be_bitflip(r)) {
5094c5296
<     if (!*(u16*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
5102a5305,5309
>       u16 r1 = orig ^ (orig + j),
>           r2 = orig ^ (orig - j),
>           r3 = orig ^ SWAP16(SWAP16(orig) + j),
>           r4 = orig ^ SWAP16(SWAP16(orig) - j);
> 
5105,5109c5312,5313
<          & 0xff overflow checks).
< 
<          Since we're looking only at multi-byte operations, the
<          overlap with bitflips will be relatively modest and we don't
<          test for it here. */
---
>          & 0xff overflow checks) and if it couldn't be a product of
>          a bitflip. */
5113c5317
<       if ((orig & 0xff) + j > 0xff) {
---
>       if ((orig & 0xff) + j > 0xff && !could_be_bitflip(r1)) {
5123c5327
<       if ((orig & 0xff) < j) {
---
>       if ((orig & 0xff) < j && !could_be_bitflip(r2)) {
5137c5341,5342
<       if ((orig >> 8) + j > 0xff) {
---
> 
>       if ((orig >> 8) + j > 0xff && !could_be_bitflip(r3)) {
5147c5352
<       if ((orig >> 8) < j) {
---
>       if ((orig >> 8) < j && !could_be_bitflip(r4)) {
5184c5389,5390
<     if (!*(u32*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
>         !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
5192a5399,5403
>       u32 r1 = orig ^ (orig + j),
>           r2 = orig ^ (orig - j),
>           r3 = orig ^ SWAP32(SWAP32(orig) + j),
>           r4 = orig ^ SWAP32(SWAP32(orig) - j);
> 
5198c5409
<       if ((orig & 0xffff) + j > 0xffff) {
---
>       if ((orig & 0xffff) + j > 0xffff && !could_be_bitflip(r1)) {
5208c5419
<       if ((orig & 0xffff) < j) {
---
>       if ((orig & 0xffff) < j && !could_be_bitflip(r2)) {
5221,5222c5432,5433
<  
<       if ((SWAP32(orig) & 0xffff) + j > 0xffff) {
---
> 
>       if ((SWAP32(orig) & 0xffff) + j > 0xffff && !could_be_bitflip(r3)) {
5232c5443
<       if ((SWAP32(orig) & 0xffff) < j) {
---
>       if ((SWAP32(orig) & 0xffff) < j && !could_be_bitflip(r4)) {
5285,5287c5496
<       /* Skip if the new and original values are the same, or are within
<          +/- ARITH_MAX (in the latter case, we already tried this number
<          during the arith steps). */
---
>       /* Skip if the value could be a product of bitflips or arithmetics. */
5289,5290c5498,5499
<       if (((u8)(interesting_8[j] - orig)) <= ARITH_MAX ||
<           ((u8)(orig - interesting_8[j])) <= ARITH_MAX) {
---
>       if (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||
>           could_be_arith(orig, (u8)interesting_8[j], 1)) {
5329c5538
<     if (!*(u16*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
5338,5340d5546
<       u8 i_msb = ((u16)interesting_16[j]) >> 8,
<          o_msb = orig >> 8;
< 
5343,5346c5549,5550
<       /* Skip if values are the same or if both the orig value and
<          the current candidate have the same MSB value and are a
<          small integer - in which case, we covered this op while
<          working on interesting_8. */
---
>       /* Skip if this could be a product of a bitflip, arithmetics,
>          or single-byte interesting value insertion. */
5348,5349c5552,5554
<       if (interesting_16[j] != orig && 
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xff))) {
---
>       if (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &&
>           !could_be_arith(orig, (u16)interesting_16[j], 2) &&
>           !could_be_interest(orig, (u16)interesting_16[j], 2, 0)) {
5360,5364c5565,5568
<       o_msb = orig;
< 
<       if (SWAP16(interesting_16[j]) != interesting_16[j] && 
<           SWAP16(interesting_16[j]) != orig &&
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xff))) {
---
>       if ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &&
>           !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &&
>           !could_be_arith(orig, SWAP16(interesting_16[j]), 2) &&
>           !could_be_interest(orig, SWAP16(interesting_16[j]), 2, 1)) {
5402c5606,5607
<     if (!*(u32*)(eff_map + EFF_APOS(i))) {
---
>     if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
>         !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
5411,5413d5615
<       u16 i_msb = ((u32)interesting_32[j]) >> 16,
<           o_msb = orig >> 16;
< 
5416,5417c5618,5623
<       if (interesting_32[j] != orig &&
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xffff))) {
---
>       /* Skip if this could be a product of a bitflip, arithmetics,
>          or word interesting value insertion. */
> 
>       if (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &&
>           !could_be_arith(orig, interesting_32[j], 4) &&
>           !could_be_interest(orig, interesting_32[j], 4, 0)) {
5428,5432c5634,5637
<       o_msb = SWAP32(orig) >> 16;
< 
<       if (SWAP32(interesting_32[j]) != interesting_32[j] && 
<           SWAP32(interesting_32[j]) != orig &&
<           (i_msb != o_msb || (o_msb != 0 && o_msb != 0xffff))) {
---
>       if ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &&
>           !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &&
>           !could_be_arith(orig, SWAP32(interesting_32[j]), 4) &&
>           !could_be_interest(orig, SWAP32(interesting_32[j]), 4, 1)) {
5668c5873
<     u32 use_stacking = 1 << UR(HAVOC_STACK_POW2 + 1);
---
>     u32 use_stacking = 1 << (1 + UR(HAVOC_STACK_POW2));
6192,6209d6396
< static int startswith(const char *str, const char *prefix)
< {
<     return strncmp(prefix, str, strlen(prefix)) == 0;
< }
< 
< 
< static int endswith(const char *str, const char *suffix)
< {
<   if (!str || !suffix)
<     return 0;
<   size_t lenstr = strlen(str);
<   size_t lensuffix = strlen(suffix);
<   if (lensuffix >  lenstr)
<     return 0;
<   return strncmp(str + lenstr - lensuffix, suffix, lensuffix) == 0;
< }
< 
< 
6214,6215d6400
<   sync_times++;
< 
6226,6227d6410
<   int from_which = 0;
< 
6245,6248d6427
<     if (!strcmp(sync_dir, out_dir))
<     {
<       if(!startswith(sd_ent->d_name, "s2e") && !endswith(sd_ent->d_name, "filter") && !startswith(sd_ent->d_name, "traffic")) continue;
<     }
6251,6263d6429
<     if(startswith(sd_ent->d_name, "s2e"))
<     {
<       from_which = S2E_SRC;
<     }
<     else if(startswith(sd_ent->d_name, "traffic"))
<     {
<       from_which = TRA_SRC;
<     }
<     else
<     {
<       from_which = FUZ_SRC;
<     }
< 
6274d6439
<     // qd_synced_path = alloc_printf("%s/.synced/%s", local_out_dir, sd_ent->d_name);
6302c6467
<           sscanf(qd_ent->d_name, CASE_PREFIX "%08u", &syncing_case) != 1 || 
---
>           sscanf(qd_ent->d_name, CASE_PREFIX "%06u", &syncing_case) != 1 || 
6321,6324d6485
<         sync_count++;
<         checked_paths[from_which]++;
< 
< 
6334c6495
<         // ACTF("run_target() 4");
---
> 
6340,6344c6501
<         u8 save_or_not = save_if_interesting(argv, mem, st.st_size, fault);
<         // queued_imported += save_if_interesting(argv, mem, st.st_size, fault);
<         queued_imported += save_or_not;
<         imported_paths[from_which] += save_or_not;
< 
---
>         queued_imported += save_if_interesting(argv, mem, st.st_size, fault);
6372d6528
< 
6379,6384c6535,6537
<   int i;
<   for(i=0; i<num_of_cbs; i++)
<   {
<     if (child_pid[i] > 0) kill(child_pid[i], SIGKILL);
<     if (forksrv_pid[i] > 0) kill(forksrv_pid[i], SIGKILL);
<   }
---
>   if (child_pid > 0) kill(child_pid, SIGKILL);
>   if (forksrv_pid > 0) kill(forksrv_pid, SIGKILL);
> 
6400,6429c6553,6562
<   child_timed_out = 1; 
<   int tag = 0;
<   int i;
<   // for(i=0; i<num_of_cbs; i++)
<   // {
<   //   if (child_pid[i] > 0) {
< 
<   //     kill(child_pid[i], SIGKILL);
< 
<   //   } else if (child_pid[i] == -1 && forksrv_pid[i] > 0) {
< 
<   //     kill(forksrv_pid[i], SIGKILL);
< 
<   //   }
<   // }
<   for(i=0; i<num_of_cbs; i++)
<   {
<     if(child_pid[i] > 0)
<     {
<       kill(child_pid[i], SIGKILL);
<       tag = 1;
<     }
<   }
<   if(tag == 0)
<   {
<     for(i=0; i<num_of_cbs; i++)
<     {
<       if(child_pid[i] == -1 && forksrv_pid[i] > 0)
<         kill(forksrv_pid[i], SIGKILL);
<     }
---
>   if (child_pid > 0) {
> 
>     child_timed_out = 1; 
>     kill(child_pid, SIGKILL);
> 
>   } else if (child_pid == -1 && forksrv_pid > 0) {
> 
>     child_timed_out = 1; 
>     kill(forksrv_pid, SIGKILL);
> 
6448c6581
<   ACTF("Validating target binary: %s...", fname);
---
>   ACTF("Validating target binary...");
6528,6531c6661,6662
<   // if (f_data[0] != 0x7f || memcmp(f_data + 1, "ELF", 3))
<   //   FATAL("Program '%s' is not an ELF binary", target_path);
<   if (f_data[0] != 0x7f || memcmp(f_data + 1, "CGC", 3))
<     FATAL("Program '%s' is not an CGC binary", target_path);
---
>   if (f_data[0] != 0x7f || memcmp(f_data + 1, "ELF", 3))
>     FATAL("Program '%s' is not an ELF binary", target_path);
6574a6706,6722
>   /* Detect persistent & deferred init signatures in the binary. */
> 
>   if (memmem(f_data, f_len, PERSIST_SIG, strlen(PERSIST_SIG) + 1)) {
> 
>     OKF(cPIN "Persistent mode binary detected.");
>     setenv(PERSIST_ENV_VAR, "1", 1);
>     no_var_check = 1;
> 
>   }
> 
>   if (memmem(f_data, f_len, DEFER_SIG, strlen(DEFER_SIG) + 1)) {
> 
>     OKF(cPIN "Deferred forkserver binary detected.");
>     setenv(DEFER_ENV_VAR, "1", 1);
> 
>   }
> 
6610c6758
< /* Check terminal dimensions. */
---
> /* Check if we're on TTY. */
6612c6760
< static void check_terminal(void) {
---
> static void check_if_tty(void) {
6626c6774
<   if (ws.ws_row < 25 || ws.ws_col < 80) {
---
> }
6628,6630d6775
<     SAYF("\n" cLRD "[-] " cRST
<          "Oops, your terminal window seems to be smaller than 80 x 25 characters.\n"
<          "    That's not enough for afl-fuzz to correctly draw its fancy ANSI UI!\n\n"
6632,6634c6777
<          "    Depending on the terminal software you are using, you should be able to\n"
<          "    resize the window by dragging its edges, or to adjust the dimensions in\n"
<          "    the settings menu.\n");
---
> /* Check terminal dimensions after resize. */
6636c6779
<     FATAL("Please resize terminal to 80x25 or more");
---
> static void check_term_size(void) {
6638c6781,6787
<   }
---
>   struct winsize ws;
> 
>   term_too_small = 0;
> 
>   if (ioctl(1, TIOCGWINSZ, &ws)) return;
> 
>   if (ws.ws_row < 25 || ws.ws_col < 80) term_too_small = 1;
6660,6661c6809
<        "  -Q            - use binary-only instrumentation (QEMU mode)\n\n" 
<        "  -L            - maintain logs under QEMU mode\n\n"   
---
>        "  -Q            - use binary-only instrumentation (QEMU mode)\n\n"     
6684,6698d6831
< /* Prepare output fds for qemu_log*/
< static void setup_qemu_log_fds(void)
< {
<   if(!qemu_mode) FATAL("qemu_log only supported under qemu_mode");
< 
<   qemu_log_fds = ck_alloc(sizeof(s32) * num_of_cbs);
<   int cb_id;
<   for(cb_id=0; cb_id<num_of_cbs; cb_id++)
<   {
<     u8* tmp = alloc_printf("%s/qemu_log_%d", out_dir, cb_id);
<     qemu_log_fds[cb_id] = open(tmp, O_RDWR|O_CREAT, 0600);
<     if(qemu_log_fds[cb_id] < 0) PFATAL("unalbe to open %s", tmp);
<     ck_free(tmp);
<   }
< }
6721a6855,6863
>     out_dir_fd = open(out_dir, O_RDONLY);
> 
> #ifndef __sun
> 
>     if (out_dir_fd < 0 || flock(out_dir_fd, LOCK_EX | LOCK_NB))
>       PFATAL("Unable to flock() output directory.");
> 
> #endif /* !__sun */
> 
6765,6766c6907
<     
<     mkdir(remote_out_dir, 0700);
---
> 
6768d6908
<     // tmp = alloc_printf("%s/.synced/", local_out_dir);
6797d6936
<   // tmp = alloc_printf("%s/plot_data", local_out_dir);
6818d6956
<   // u8* fn = alloc_printf("%s/.cur_input", local_out_dir);
6843c6981
<   if (system("launchctl bslist 2>/dev/null | grep -q '\\.ReportCrash$'")) return;
---
>   if (system("launchctl list 2>/dev/null | grep -q '\\.ReportCrash$'")) return;
6857c6995,6996
<   FATAL("Crash reporter detected");
---
>   if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
>     FATAL("Crash reporter detected");
6884c7023,7024
<     FATAL("Pipe at the beginning of 'core_pattern'");
---
>     if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
>       FATAL("Pipe at the beginning of 'core_pattern'");
7054c7194
<   if (strlen(sync_id) > 64) FATAL("Fuzzer ID too long");
---
>   if (strlen(sync_id) > 32) FATAL("Fuzzer ID too long");
7058,7061c7198
<   if(!sync_dir)
<   {
<     sync_dir = out_dir;
<   }
---
>   sync_dir = out_dir;
7116d7252
<       {
7118,7119d7253
<         // out_file = alloc_printf("%s/.cur_input", local_out_dir);
<       }
7189a7324,7326
> 
> /* Rewrite argv for QEMU. */
> 
7192,7193c7329,7338
<   /* First we should set the target_path to afl-qemu-trace */
<   u8* tmp, *cp, *rsl, *own_copy;
---
>   char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
>   u8 *tmp, *cp, *rsl, *own_copy;
> 
>   memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
> 
>   new_argv[2] = target_path;
>   new_argv[1] = "--";
> 
>   /* Now we need to actually find the QEMU binary to put in argv[0]. */
> 
7195,7196c7340,7342
<   if (tmp) 
<   {
---
> 
>   if (tmp) {
> 
7202,7203c7348,7350
<     target_path =  cp;
<     goto set_tp_done;
---
>     target_path = new_argv[0] = cp;
>     return new_argv;
> 
7208,7209c7355,7357
<   if (rsl) 
<   {
---
> 
>   if (rsl) {
> 
7210a7359
> 
7213,7216c7362,7367
<     if (!access(cp, X_OK)) 
<     {
<       target_path =  cp;
<       goto set_tp_done;
---
> 
>     if (!access(cp, X_OK)) {
> 
>       target_path = new_argv[0] = cp;
>       return new_argv;
> 
7220,7224c7371,7376
<   
<   if (!access(AFL_PATH "/afl-qemu-trace", X_OK)) 
<   {
<     target_path =  ck_strdup(AFL_PATH "/afl-qemu-trace");
<     goto set_tp_done;
---
> 
>   if (!access(BIN_PATH "/afl-qemu-trace", X_OK)) {
> 
>     target_path = new_argv[0] = ck_strdup(BIN_PATH "/afl-qemu-trace");
>     return new_argv;
> 
7228,7235c7380,7387
<          "Oops, unable to find the 'afl-qemu-trace' binary. The binary must be built\n"
<          "    separately by following the instructions in qemu_mode/README.qemu. If you\n"
<          "    already have the binary installed, you may need to specify AFL_PATH in the\n"
<          "    environment.\n\n"
< 
<          "    Of course, even without QEMU, afl-fuzz can still work with binaries that are\n"
<          "    instrumented at compile time with afl-gcc. It is also possible to use it as a\n"
<          "    traditional \"dumb\" fuzzer by specifying '-n' in the command line.\n");
---
>        "Oops, unable to find the 'afl-qemu-trace' binary. The binary must be built\n"
>        "    separately by following the instructions in qemu_mode/README.qemu. If you\n"
>        "    already have the binary installed, you may need to specify AFL_PATH in the\n"
>        "    environment.\n\n"
> 
>        "    Of course, even without QEMU, afl-fuzz can still work with binaries that are\n"
>        "    instrumented at compile time with afl-gcc. It is also possible to use it as a\n"
>        "    traditional \"dumb\" fuzzer by specifying '-n' in the command line.\n");
7238,7254c7390
<   
< set_tp_done:  
<   ACTF("reset target_path is done");
<   char** new_argv = ck_alloc(sizeof(char*) * argc * 4);
<   int i;
<   for(i=0; i<argc; i++)
<   {
<     int th = i * 4;
<     new_argv[th] = target_path;
<     if(is_qemu_log)
<       new_argv[th+1] = "-strace";
<     else
<       new_argv[th+1] = "--";
<     new_argv[th+2] = ck_strdup(argv[i]);
<     new_argv[th+3] = NULL;
<   } 
<   return new_argv;
---
> 
7285,7298d7420
< // void backup_stat(char** stat_vector, int cnt)
< // {
< //   char filepath[] = "/home/vagrant/cc_server/afl_fuzz_stat.txt";
< //   FILE* pFile = fopen(filepath, "w+");
< //   if(pFile != NULL) 
< //   {
< //     int i;
< //     for(i = 0; i < cnt; i++ )
< //     {
< //       fprintf(pFile, "%s\n", stat_vector[i]);
< //     }
< //     fclose(pFile);
< //   }
< // }
7310c7432
<   cksum2paths = kh_init(32);  
---
>   cksum2paths = kh_init(32);
7314,7315c7436
<   SAYF(cCYA "afl-fuzz " cBRI VERSION cRST " (" __DATE__ " " __TIME__ 
<        ") by <lcamtuf@google.com>\n");
---
>   SAYF(cCYA "afl-fuzz " cBRI VERSION cRST " by <lcamtuf@google.com>\n");
7317a7439
>   while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:Q:a")) > 0)
7319,7324d7440
<   // local_out_dir = alloc_printf("/home/vagrant/local_outputs");
<   remote_out_dir = alloc_printf("/home/vagrant/shared_outputs");
< 
<   while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:QLs:")) > 0) 
<   {
<     // ACTF("opt: %c", opt);
7340d7455
<         // local_out_dir = alloc_printf("/home/vagrant/local_outputs");
7351d7465
<         // local_out_dir = alloc_printf("%s/%s", local_out_dir, sync_id);
7353,7358d7466
<         remote_out_dir = alloc_printf("%s/%s", remote_out_dir, sync_id);
<         break;
< 
<       case 's':
<         if(sync_dir) FATAL("Multiple -s options not supported");
<         sync_dir = optarg;
7379,7380c7487,7488
<           if (sscanf(optarg, "%u%c", &exec_tmout, &suffix) < 1)
<             FATAL("Bad syntax used for -t");
---
>           if (sscanf(optarg, "%u%c", &exec_tmout, &suffix) < 1 ||
>               optarg[0] == '-') FATAL("Bad syntax used for -t");
7404,7405c7512,7513
<           if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1)
<             FATAL("Bad syntax used for -m");
---
>           if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1 ||
>               optarg[0] == '-') FATAL("Bad syntax used for -m");
7480,7485d7587
< 
<       case 'L':
< 
<         if(is_qemu_log) FATAL("Multiple -L options not supported");
<         is_qemu_log = 1;
<         break;
7491d7592
<   }
7521c7622
<   check_terminal();
---
>   check_if_tty();
7527,7531c7628
<   //assume that all remaining arguments are about /path/to/cb
<   num_of_cbs = argc - optind;
<   top_rated = ck_alloc(sizeof(struct queue_entry*) * num_of_cbs * MAP_SIZE);
<   init_cbs_comm_fds();
< 
---
>   setup_post();
7535,7538d7631
< 
<   if(is_qemu_log)
<     setup_qemu_log_fds();
< 
7545a7639,7640
>   if (!timeout_given) find_timeout();
> 
7550,7557c7645
<   stat_vector[0] = out_dir;
<   int _i = 0;
<   while(argv[optind+_i])
<   {
<     check_binary(argv[optind + _i]);
<     stat_vector[_i+1] = argv[optind + _i];
<     _i++;
<   }
---
>   check_binary(argv[optind]);
7560c7648
<  
---
> 
7566,7577d7653
<   ACTF("There are %i CBs for this sample", num_of_cbs); 
<   _i = 0;
<   for(_i = 0; _i < num_of_cbs; _i++)
<   {
<     int _j;
<     for(_j=0; _j<3; _j++)
<       ACTF("use_argv[%i]: %s", _i*4 + _j , use_argv[_i*4 + _j]);
< 
<     ACTF("use_argv[%i]: 0x%02lx",_i*4 + 3, (unsigned long int)use_argv[_i*4 + 3]);
<   }
<   ACTF("target_path_: %s", target_path);
< 
7580,7583d7655
<   // backup_stat(stat_vector, num_of_cbs + 1);
< 
<   // goto stop_fuzzing;
<   
